<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joyer的博客</title>
  
  <subtitle>Lahee~</subtitle>
  <link href="https://blog.joyer.top/atom.xml" rel="self"/>
  
  <link href="https://blog.joyer.top/"/>
  <updated>2022-12-14T08:43:14.806Z</updated>
  <id>https://blog.joyer.top/</id>
  
  <author>
    <name>JoyerLiu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>兜兜转转兜兜--关于Android开发中 Fragment 生命周期 OnActivityCreated() 被弃用以及在 Fragment 监听按钮跳转页面</title>
    <link href="https://blog.joyer.top/2022-12-02/"/>
    <id>https://blog.joyer.top/2022-12-02/</id>
    <published>2022-12-02T13:09:48.000Z</published>
    <updated>2022-12-14T08:43:14.806Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>正在学习Android的路上，服完国内这帮老掉牙的技术教程了，个人本想在 Fragment 中实现页面的跳转，奈何却被绊倒在了监听按钮事件上。</p><h2 id="破事其一-OnActivityCreated-被弃用"><a href="#破事其一-OnActivityCreated-被弃用" class="headerlink" title="破事其一 OnActivityCreated()被弃用"></a>破事其一 OnActivityCreated()被弃用</h2><p>Fragment 的 OnActivityCreated() 方法早已不能使用，国内大部分抄来抄去的教程还在tmd用这个方法教！官方的意思是为了减少页面耦合性，这我能理解，在这个方法弃用之后官方给出了一个解决方案——即使用 Lifecycle 来监听 Activity 的 Created 状态，即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">requireActivity().getLifecycle().addObserver(<span class="keyword">new</span> LifecycleEventObserver() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> <span class="meta">@NotNull</span> LifecycleOwner source, <span class="meta">@NonNull</span> <span class="meta">@NotNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (event.getTargetState() == Lifecycle.State.CREATED) &#123;<span class="comment">//监听Activity的Created事件</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//这里写希望执行的代码段</span></span><br><span class="line"></span><br><span class="line">                    getLifecycle().removeObserver(<span class="keyword">this</span>);  <span class="comment">//删除观察者</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>将这一大串放在 Fragment 的 OnAttach() 中，当 Lifecycle 检测到 Fragment 的 Activity 创建流程有所变动，就能捕捉到并运行 onStateChanged() 。</p><h2 id="破事其二-过去的-Fragment-看不到未来的-Activity"><a href="#破事其二-过去的-Fragment-看不到未来的-Activity" class="headerlink" title="破事其二 过去的 Fragment 看不到未来的 Activity"></a>破事其二 过去的 Fragment 看不到未来的 Activity</h2><p>OnActivityCreated() 的问题确实解决了。但这有一个问题，我想要的效果是点击按钮后跳转到新的页面，而跳转这个动作需要执行 startActivity(Intent(Activity,NextAvtivity.class)) ,Intent 参数中的 Class 问题不大肯定有，但要怎么让过去的 Fragment 提供一个未来的 Activity 呢。</p><p>如下图所示，这是 Fragment 生命周期中能够被获取到的几个状态</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/08/31722863.jpg"></p><p>只有当 OnActivityCreated 时，Fragment 才能知晓可用的 Activity ，在此之前如果你使用 getActivity() 会回返 null ，所以我们在 ActivityCreated 之前的Fragment 中 getActivity() 的回返都会是 null 。</p><p>看着图思考，终于脑袋开窍，峰回路转。既然我不能在 OnActivityCreated,我使用下一条流程 OnStart() 不就行了嘛，因为追究 OnActivityCreated() 这破事，害的我完全钻进了牛角尖，老旧教程害人啊🤣。</p><p>所以我们只需要选择在 OnActivityCreated() 流程之后的 OnStart() 流程设置点击监听就ok了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();  <span class="comment">//在OnStart()设置控件的点击事件！</span></span><br><span class="line">    regOnClick();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">regOnClick</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    OptionView optionViewLog = (OptionView) getActivity().findViewById(R.id.logOption);</span><br><span class="line">    ;</span><br><span class="line">    optionViewLog.findViewById(R.id.optionList).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">            intent.setClass(getActivity(), LogActivity.class); </span><br><span class="line">            startActivity(intent); <span class="comment">//跳转！</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此这般，你就发现你的跳转能用了。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这篇教程是一边写一边思考一边码代码的，除了水水博客,也是为了整理思路，有任何纰漏，烦请大神指点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="技术" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Android" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/Android/"/>
    
    
    <category term="教程" scheme="https://blog.joyer.top/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Android" scheme="https://blog.joyer.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>00后小屁孩的怀旧，爱华 T30 磁带机，真是又爱又恨</title>
    <link href="https://blog.joyer.top/2022-10-25/"/>
    <id>https://blog.joyer.top/2022-10-25/</id>
    <published>2022-10-25T11:20:54.000Z</published>
    <updated>2022-12-14T08:48:27.883Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博文所有的所有都得从我那天生日开始……当天我亲爱的舍友给我发来信息说想送我一个生日礼物，并展示手办图片给我看问我喜欢哪个，很感谢舍友有这份心，即使他也并不混二刺螈也知道我满桌的景品是初音未来。</p><p>在来回推辞拉扯之后我最终还是接受了来自舍友的礼物，总所周知我是一个不折不扣的轻音粉，所以为了不让他太过破费，我改成了一张轻音少女的翻录盘，也就是在第二集中众人一起在部室录下的这张盘子。<img src="https://blog.joyer.top/2022-10-25/IMG20220926165841.jpg"></p><p>想要这个盘子很久了，惊喜的是能够发现有翻录盘，就算是翻录事实上我其实也能接受。</p><h1 id="正文-跳进大坑的开始"><a href="#正文-跳进大坑的开始" class="headerlink" title="正文(跳进大坑的开始)"></a>正文(跳进大坑的开始)</h1><p>有了碟醋就想包盘饺子，于是我在二手平台瞎琢磨最终买下了一台爱华 T30。</p><p><img src="https://blog.joyer.top/2022-10-25/IMG20220929162509.jpg"></p><p>买爱华T30 主要还是为了两点：</p><ul><li>1、第一次碰磁带机，我想要功能更多的。</li><li>2、它至少得我能支付的起。</li></ul><p>如此如此这般这般这台磁带机最终来到了我的手中。</p><h2 id="它的一些功能"><a href="#它的一些功能" class="headerlink" title="它的一些功能"></a>它的一些功能</h2><p>在买磁带机的时候我是做了些功课。爱华 T30 有着杜比降噪（其实我买的时候还以为是杜比音效）、自动翻带（一般都会有）、均衡器（很少有），我没注意到的是它 TM 居然还能从一类带听到三类带（这个我可以以后再起一篇专门介绍磁带的分类）。最主要的还是它是砖机，而不是超薄机。</p><h3 id="关于体积（带速与机械按钮）"><a href="#关于体积（带速与机械按钮）" class="headerlink" title="关于体积（带速与机械按钮）"></a>关于体积（带速与机械按钮）</h3><p>可以看到这机器其实是比较大的，我的一只手完全握不下，这家伙巨大的原因主要是它的机芯占地方多，机芯其实是决定了磁带机走速稳不稳的一个重要因素，而其中的飞轮则担任了稳定带速的重要角色，电机的速率其实不是匀称的，受到外界的干扰或是电流自身的问题速率都会变化，不说有刷电机，无刷电机也是一样。对于磁带机来说带速是很重要的，稍微一点的带速变化都会放大到人的耳朵里导致听着不对。为了稳定速率，飞轮越大越重，转向惯量也就越大，那么速度变化也会越平缓（说得可能不太对，大抵原理是这样）。卡座有着超大的飞轮和超稳的转速是它相对磁带随身听更好的一部分原因。回到砖机上，这家伙由着大体量的优势自然也得到了更大的空间去塞飞轮，有着比超薄随身听更好的稳速。</p><p>另外一部分原因大家其实也能看得到，就是它是机械式按钮，这一部分也需要牺牲一些厚度。个人认为机械式按钮要比超薄机上的更好，一个自然是它的反馈来的更直接真实，应该有些朋友小时候放英语听力时有见过磁带机（这自然也是为啥我们这代能接触到磁带机），老师放听力时几个按钮轮着按，咔嚓~啪一声弹响是真的清脆又舒服），另外一个则是个人不太信任电控按钮，总觉得会坏以及难修。</p><h2 id="拿到手之后"><a href="#拿到手之后" class="headerlink" title="拿到手之后"></a>拿到手之后</h2><p>我虽然有注意买别人大佬打理好的机器，但是拿到手后效果还是不尽理想，人声听起来没啥问题，到了背景音就完了，幽怨上下跳动的音调简直就想卡通片里的果冻音效，或是鬼片里的幽灵音效。得，还是得自己打理。</p><h2 id="打理磁带机是一个大坑"><a href="#打理磁带机是一个大坑" class="headerlink" title="打理磁带机是一个大坑"></a>打理磁带机是一个大坑</h2><p>上边出现的现象其实就是颤音，究其原因就是带子在经过磁头时不老实，或上下乱动或忽快忽慢，导致磁头读到的信号不连续，所以是传动部分的原因。收集信息后，我总结了一下磁带的走带结构,有朋友需要的我也找来了该机型的机芯结构可以看看。</p><p>这个是我随手画的一图，不是很好看。看磁带的走向不难看出，想让磁带不老实乱晃，那么其原因可能就是压带轮形状变形了、主导轴歪了、皮带快不行了、甚至有可能是导带槽方向歪了。。所以大家在判断颤音问题的时候，其实建议能够开仓查看一下磁带机的运行情况，再做进一步的判断。</p><p>一般来说如果发现走带速度忽快忽慢的话，就得考虑更换牵动主导轴的皮带，很有可能皮带松了，或者摩擦力不一样导致打滑了。</p><p>如果发现走带不稳呢，就把磁带拿出来，开仓空转一下查看主导轴是否歪了（这是非常要命的，歪一点点都不行！），静止状态下主导轴歪曲肉眼不容易看出来，当旋转起来后就非常明显了；如果主导轴真的没歪，那就很可能是压带轮了，更换压带轮吧朋友，没有办法。</p><p>当然了，也不能排除磁带的问题，一些磁带过于老旧或使用过多或本身质量不行，由于物理变形导致声像的变形。</p><p>我还找到了爱华 T30 的维修手册，如果有需要可以直达 <a href="https://blog.joyer.top/aiwa_hs-t30_sm.pdf">爱华T30维修手册</a> ，这里放出来的是机芯部分，大多数朋友应该够用了。</p><p><img src="https://blog.joyer.top/2022-10-25/KT69L5W6QGMMH$X9OEHCGJE.png"></p><p><img src="https://blog.joyer.top/2022-10-25/-2157c4ebf5655450.jpg"></p><h2 id="开拆！"><a href="#开拆！" class="headerlink" title="开拆！"></a>开拆！</h2><p>从上一家卖家手里拿到了两个关于爱华 T30 的零件机吭哧吭哧就开拆，上家其实保养得不错，除了飞线有点难看问题不大。</p><p><img src="https://blog.joyer.top/2022-10-25/IMG20220930203345.jpg"></p><p>拆得七零八落后我终于看到了机芯，给大家看看实际的机芯</p><p><img src="https://blog.joyer.top/2022-10-25/IMG20221001212232.jpg"></p><p>一套更换完毕上油，机芯顺滑了不少，颤音也收敛不少，虽然还是十分明显的，不过也只能这样了，这是能找到最好状态的替换件，以后有机会可能还会再淘淘再更换，大写爱华不能落寞！</p><p><img src="https://blog.joyer.top/2022-10-25/IMG20221022191135.jpg"></p><p>放上视频给大家感受一下打理前与打理后的区别（其实我感觉没啥区别,可能好了一丢丢）。</p><div style="position:relative; padding-bottom:75%; width:100%; height:0">    <iframe src="//player.bilibili.com/player.html?bvid=BV1dP411J7vs&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position:absolute; height: 100%; width: 100%;"></iframe></div><div style="position:relative; padding-bottom:75%; width:100%; height:0">    <iframe src="//player.bilibili.com/player.html?bvid=BV1bR4y1d7X6&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position:absolute; height: 100%; width: 100%;"></iframe></div><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这篇 blog 或许还会再更新，敬请期待大写爱华的传奇。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数码" scheme="https://blog.joyer.top/categories/%E6%95%B0%E7%A0%81/"/>
    
    
    <category term="数码产品" scheme="https://blog.joyer.top/tags/%E6%95%B0%E7%A0%81%E4%BA%A7%E5%93%81/"/>
    
    <category term="怀旧" scheme="https://blog.joyer.top/tags/%E6%80%80%E6%97%A7/"/>
    
    <category term="磁带机" scheme="https://blog.joyer.top/tags/%E7%A3%81%E5%B8%A6%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode每日一题 442. 数组中重复的数据</title>
    <link href="https://blog.joyer.top/2022-05-08/"/>
    <id>https://blog.joyer.top/2022-05-08/</id>
    <published>2022-05-08T05:42:35.000Z</published>
    <updated>2022-05-08T06:32:12.432Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>今天是一道值得用来讲的题目，来看题 <a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/">LeetCode 442. 数组中重复的数据</a> 。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，其中 <code>nums</code> 的所有整数都在范围 <code>[1, n]</code> 内，且每个整数出现 <strong>一次</strong> 或 <strong>两次</strong> 。请你找出所有出现 两次 的整数，并以数组形式返回。</p><p>你必须设计并实现一个时间复杂度为 <strong>O(n)</strong> 且仅使用常量额外空间的算法解决此问题。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,3,2,7,8,2,3,1]</span><br><span class="line">输出：[2,3]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>注：题目来源于 <a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/">LeetCode 442. 数组中重复的数据</a> </p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这道题如果不加额外条件其实很简单，但是它加了额外条件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">必须设计并实现一个时间复杂度为 O(n) 且仅使用常量额外空间的算法解决此问题</span><br></pre></td></tr></table></figure><p><code>常量额外空间</code>即O(1)，代表着我们除了用来输出输入的空间只能再加入空间固定的变量。而<code>时间复杂度O(n)</code>则是要求我们只能有一层循环。<br>那么在时间和空间都那么紧张的条件下我们能做什么呢？我们可以注意到题目中的两个条件：</p><ul><li><code>nums</code> 的所有整数都在范围 <code>[1, n]</code> 内</li><li>整数数组 <code>nums</code> 长度为 <code>n</code> </li></ul><p>对于一个数组来说，它能包含的信息除了数组中的元素还有什么呢？对了，就是每个元素的下标。因为题目中nums的长度为 <code>n</code> 而 <code>nums</code> 的元素范围在 <code>[1, n]</code>，我们大可通过修改 <strong>下标为val</strong> 的元素的值来标志 <strong>值为val</strong> 的元素是否出现过而不影响我们使用 <code>nums</code> 里面的所有元素。</p><p>重申一遍， <strong><code>nums</code> 的元素范围在 <code>[1, n]</code> 中</strong> 。我们可以通过 <code>num[val-1]*=-1</code> 令其成为负数标志 <code>val</code> 这个数已经在 <code>nums</code> 中出现过一次了，而我们如果需要使用 <code>num[val-1]</code> 则只需要使用其绝对值 <code>abs(num[val-1])</code> 即可。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时：40 ms, 在所有 C++ 提交中击败了84.35%的用户</span></span><br><span class="line"><span class="comment">//内存消耗：32.7 MB, 在所有 C++ 提交中击败了66.33%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> num=<span class="built_in">abs</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(nums[num<span class="number">-1</span>]&gt;<span class="number">0</span>)</span><br><span class="line">                nums[num<span class="number">-1</span>]*=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans.<span class="built_in">push_back</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><p>此解法非唯一解，且不一定是最好的解法，如果您有更好的解法，欢迎在评论区中提出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="技术" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="算法" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"/>
    
    <category term="学习日志" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="C++" scheme="https://blog.joyer.top/tags/C/"/>
    
    <category term="算法" scheme="https://blog.joyer.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://blog.joyer.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>国内部分社区 APP 上线 IP 属地之后的一些思考</title>
    <link href="https://blog.joyer.top/2022-05-02/"/>
    <id>https://blog.joyer.top/2022-05-02/</id>
    <published>2022-05-01T16:08:37.000Z</published>
    <updated>2022-05-01T16:51:32.478Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>就在最近国内许多社交 APP 相继上线了在个人账号边显示 IP 属地的一个小功能，并且是强制的，刚上线就遭到老百姓们的议论，有人说这样会出现隐私问题，但有人也非常看好。  </p><p><img src="https://blog.joyer.top/2022-05-02/2.jpg"></p><p>对于这个功能我倒是比较看好的，网络舆论是一个很恐怖的东西，如果被某些不安好心的个人或者组织对网络社交进行渗透，很有可能能够控制整个网络社交的风向，这对网络安全甚至上升到国家安全都是一件非常严肃的事情。</p><p>靠着这个功能很快就能够发现平日里一些出言不逊的“大拳师”、“精日”、“精美”突然没了踪迹，很是解气。</p><p>比较好玩的是在这个功能上线之后，社交APP里的好多靠着分享“国外”生活赢取流量的大V直接被揭穿，说是在国外的但事实上 IP 属地却在国内，很是让人好笑（当然不能排除为了能访问国内网站而搭上回国梯子的一些用户，这种情况是存在的）（图源网络如侵删）。</p><p><img src="https://blog.joyer.top/2022-05-02/1.jpeg"></p><p>虽然这个功能很容易被破解，破解的方法我就不说了，大家都懂，但是这个功能的上线是非常好的一个开始，能够有效扫除网络中的一部分垃圾信息与不实信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="杂谈" scheme="https://blog.joyer.top/categories/%E6%9D%82%E8%B0%88/"/>
    
    <category term="瞎叭叭" scheme="https://blog.joyer.top/categories/%E6%9D%82%E8%B0%88/%E7%9E%8E%E5%8F%AD%E5%8F%AD/"/>
    
    
    <category term="网络安全" scheme="https://blog.joyer.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>实现路由器检测网络状态并重新登录</title>
    <link href="https://blog.joyer.top/2022-05-01/"/>
    <id>https://blog.joyer.top/2022-05-01/</id>
    <published>2022-05-01T15:51:16.000Z</published>
    <updated>2022-05-01T17:04:54.938Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>书接上回，自发布文章 <a href="https://blog.joyer.top/2021-12-03-3/">无锡学院校园网 实现路由器自动登录上网 支持多设备连接</a> 之后使用这个脚本已经过了差不多大半年了，依然很好用。<br>但最近经常发现路由器会无故掉线，思考可能是校园网的动态 IP 的持有时间被缩短然后强制下线，或者也有可能是系统问题，遂再写脚本实现<code>检测网络连接状态并重新登录</code>。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>其实实现这个脚本也是非常简单，这里直接给出代码,复制粘贴即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">timeout=5</span><br><span class="line">url=www.baidu.com</span><br><span class="line">if [ $(curl -I -s --connect-timeout $&#123;timeout&#125; $&#123;url&#125; -w %&#123;http_code&#125; | tail -n1) = &quot;200&quot; ]</span><br><span class="line">then</span><br><span class="line">echo &quot;network is online&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;network not connect&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">执行登录脚本</span></span><br><span class="line">sh /etc/storage/bjxy_auto_log.sh</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>原理是使用 curl 命令的 <code>-w %&#123;http_code&#125;</code> 参数读取网站的 http 状态码，如果是 200 则证明网络通畅，后上传路由器设定计划任务即可，这里不再赘述，有需要可阅 <a href="https://blog.joyer.top/2021-12-03-3/">无锡学院校园网 实现路由器自动登录上网 支持多设备连接</a> 中上传路由器的部分。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="技术" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="脚本" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/%E8%84%9A%E6%9C%AC/"/>
    
    
    <category term="脚本" scheme="https://blog.joyer.top/tags/%E8%84%9A%E6%9C%AC/"/>
    
    <category term="教程" scheme="https://blog.joyer.top/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>天文</title>
    <link href="https://blog.joyer.top/photo-tianwen/"/>
    <id>https://blog.joyer.top/photo-tianwen/</id>
    <published>2022-04-17T07:32:32.000Z</published>
    <updated>2022-04-17T08:00:21.592Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="2020年8月30日摄"><a href="#2020年8月30日摄" class="headerlink" title="2020年8月30日摄"></a>2020年8月30日摄</h1><div class="fj-gallery"><p><img src="http://blog.joyer.top/photo-tianwen/1.jpeg"><br><img src="http://blog.joyer.top/photo-tianwen/2.jpeg">  </p>          </div>]]></content>
    
    
    <summary type="html">欲上九天揽星辰</summary>
    
    
    
    <category term="摄影" scheme="https://blog.joyer.top/categories/%E6%91%84%E5%BD%B1/"/>
    
    <category term="天文" scheme="https://blog.joyer.top/categories/%E6%91%84%E5%BD%B1/%E5%A4%A9%E6%96%87/"/>
    
    
    <category term="摄影" scheme="https://blog.joyer.top/tags/%E6%91%84%E5%BD%B1/"/>
    
    <category term="照片" scheme="https://blog.joyer.top/tags/%E7%85%A7%E7%89%87/"/>
    
    <category term="天文" scheme="https://blog.joyer.top/tags/%E5%A4%A9%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>风光</title>
    <link href="https://blog.joyer.top/photo-fengguang/"/>
    <id>https://blog.joyer.top/photo-fengguang/</id>
    <published>2022-04-17T07:10:08.000Z</published>
    <updated>2022-12-14T09:03:14.383Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="2022年9月25日摄"><a href="#2022年9月25日摄" class="headerlink" title="2022年9月25日摄"></a>2022年9月25日摄</h1><div class="fj-gallery"><p><img src="http://blog.joyer.top/photo-fengguang/20220925-_DSC4671.jpg"><br><img src="http://blog.joyer.top/photo-fengguang/20220925-_DSC4691.jpg"><br><img src="http://blog.joyer.top/photo-fengguang/20220925-_DSC4749.jpg"></p>          </div><h1 id="2021年10月3日摄"><a href="#2021年10月3日摄" class="headerlink" title="2021年10月3日摄"></a>2021年10月3日摄</h1><div class="fj-gallery"><p><img src="http://blog.joyer.top/photo-fengguang/6.jpeg"><br><img src="http://blog.joyer.top/photo-fengguang/5.jpeg"></p>          </div><h1 id="2021年8月19日摄"><a href="#2021年8月19日摄" class="headerlink" title="2021年8月19日摄"></a>2021年8月19日摄</h1><div class="fj-gallery"><p><img src="http://blog.joyer.top/photo-fengguang/1.jpeg"><br><img src="http://blog.joyer.top/photo-fengguang/2.jpeg"><br><img src="http://blog.joyer.top/photo-fengguang/3.jpeg"><br><img src="http://blog.joyer.top/photo-fengguang/4.jpeg"></p>          </div><h1 id="2020年7月8日摄"><a href="#2020年7月8日摄" class="headerlink" title="2020年7月8日摄"></a>2020年7月8日摄</h1><div class="fj-gallery"><p><img src="http://blog.joyer.top/photo-fengguang/7.jpeg"><br><img src="http://blog.joyer.top/photo-fengguang/8.jpeg"></p>          </div>]]></content>
    
    
    <summary type="html">地球 Online 强势推荐，新增风光 DLC 好评如潮</summary>
    
    
    
    <category term="摄影" scheme="https://blog.joyer.top/categories/%E6%91%84%E5%BD%B1/"/>
    
    <category term="风光" scheme="https://blog.joyer.top/categories/%E6%91%84%E5%BD%B1/%E9%A3%8E%E5%85%89/"/>
    
    
    <category term="摄影" scheme="https://blog.joyer.top/tags/%E6%91%84%E5%BD%B1/"/>
    
    <category term="风光" scheme="https://blog.joyer.top/tags/%E9%A3%8E%E5%85%89/"/>
    
    <category term="照片" scheme="https://blog.joyer.top/tags/%E7%85%A7%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>人文</title>
    <link href="https://blog.joyer.top/photo-renwen/"/>
    <id>https://blog.joyer.top/photo-renwen/</id>
    <published>2022-04-17T06:50:06.000Z</published>
    <updated>2022-12-14T09:06:04.679Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="2022年9月25日摄"><a href="#2022年9月25日摄" class="headerlink" title="2022年9月25日摄"></a>2022年9月25日摄</h1><div class="fj-gallery"><p><img src="http://blog.joyer.top/photo-renwen/20220925-_DSC4567.jpg"><br><img src="http://blog.joyer.top/photo-renwen/20220925-_DSC4580.jpg"><br><img src="http://blog.joyer.top/photo-renwen/20220925-_DSC4681.jpg">  </p>          </div><h1 id="2022年2月11日摄"><a href="#2022年2月11日摄" class="headerlink" title="2022年2月11日摄"></a>2022年2月11日摄</h1><div class="fj-gallery"><p><img src="http://blog.joyer.top/photo-renwen/1.jpeg"><br><img src="http://blog.joyer.top/photo-renwen/2.jpg"><br><img src="http://blog.joyer.top/photo-renwen/3.jpg">  </p>          </div><h1 id="2021年10月3日摄"><a href="#2021年10月3日摄" class="headerlink" title="2021年10月3日摄"></a>2021年10月3日摄</h1><div class="fj-gallery"><p><img src="http://blog.joyer.top/photo-renwen/4.jpeg"><br><img src="http://blog.joyer.top/photo-renwen/5.jpeg"><br><img src="http://blog.joyer.top/photo-renwen/6.jpeg"></p>          </div>]]></content>
    
    
    <summary type="html">人间烟火</summary>
    
    
    
    <category term="摄影" scheme="https://blog.joyer.top/categories/%E6%91%84%E5%BD%B1/"/>
    
    <category term="人文" scheme="https://blog.joyer.top/categories/%E6%91%84%E5%BD%B1/%E4%BA%BA%E6%96%87/"/>
    
    
    <category term="摄影" scheme="https://blog.joyer.top/tags/%E6%91%84%E5%BD%B1/"/>
    
    <category term="照片" scheme="https://blog.joyer.top/tags/%E7%85%A7%E7%89%87/"/>
    
    <category term="人文" scheme="https://blog.joyer.top/tags/%E4%BA%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode每日一题 357. 统计各位数字都不同的数字个数</title>
    <link href="https://blog.joyer.top/2022-04-11/"/>
    <id>https://blog.joyer.top/2022-04-11/</id>
    <published>2022-04-11T00:11:56.000Z</published>
    <updated>2022-04-17T01:53:24.219Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>残念，博主对于 dp 真的非常地深恶痛绝，实在是学不会 dp 其中的精髓，dp 苦手 😩，所以今天的每日一题放弃吧。</p><p><img src="https://blog.joyer.top/2022-04-11/1.jpg"></p><p>开玩笑，明明是每日一题欸！ <a href="https://leetcode-cn.com/problems/count-numbers-with-unique-digits/">LeetCode 357. 统计各位数字都不同的数字个数</a> 。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个整数 n ，统计并返回各位数字都不同的数字 x 的个数，其中 0 &lt;= x &lt; 10^n 。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：91</span><br><span class="line">解释：答案应为除去 11、22、33、44、55、66、77、88、99 外，在 0 ≤ x &lt; 100 范围内的所有数字。 </span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>刚看完：好欸又是暴力完活的一天！…… 但是这个难度绝对不会是暴力能够解决的！</p><p>仔细思索可以发现，当 <code>n=2</code> 时，我们易得出重复数字是 11、22、33、44……88、99 这几个，那么当 <code>n=3</code> 时呢？会发现这里面包含了 9 个 <code>n=2</code> 的重复数字 x11、x22……x99 ，当然也有诸如 100、101、202…… 这样的数字当然也是。</p><p>所以这样子有叠加性质的答案绝对是动态规划无疑了！（动规真乃天杀我也！！！）</p><p>所以我们应该开始往动规的方向去思考这道题的转移方程了，但是我不会写x（绝望） 。</p><p><img src="https://blog.joyer.top/2022-04-11/1.jpg"></p><p>所以直接一点好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i]= dp[i<span class="number">-1</span>] + ( dp[i<span class="number">-1</span>] - dp[i<span class="number">-2</span>] ) * (<span class="number">10</span> - i - <span class="number">1</span> );</span><br></pre></td></tr></table></figure><ul><li><p><code>dp [ i-1 ]</code> 应该是不用解释的；  </p></li><li><p><code>(10 - i - 1 )</code> 可以举个栗子：</p><blockquote><p>n=2 时，符合题意的数字共有 91个，剩余的 <del>被选中的孩子</del> 其实是在 n=1 的数字中刚好选择了能让它成为重复数字的非重复数字，像 1 选择了 1 成为了 11，但如果它选择的是除 1 以外的 其他 9 个数字就不会叛变了。  </p></blockquote><blockquote><p>n=3 时情况也是一样的，叛变的 n=2 中的某些数字在成为三位数时恰好选择了能让它成为重复数字的数字，像是 13 找了个 1 成为了 113，这样的数字如果选择的是 1 和 3 之外的 8 个数字就不会叛变了。</p></blockquote><p>有没有发现？叛变了的数字是其中占比的 i-1/10 ，而没叛变的数字是其中占比的 <code>1-(i-1/10)</code> 也就是 <code>( dp[i-1] - dp[i-2] ) * (10 - i - 1 )</code> 了。</p></li><li><p><code>( dp[i-1] - dp[i-2] )</code> 其实是为了避免重复计算。在上面的例子中，因为 位数为 1 的数 在 <code>n=2</code> 时就已经被计算了，我们只需要关心 位数为 2 的数就可以了。</p></li></ul><p>题解就是这么多了，写代码吧！</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用时0ms 超越 100% 消耗 5.9MB 超越34.29%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+(dp[i<span class="number">-1</span>]-dp[i<span class="number">-2</span>])*(<span class="number">10</span>-(i<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><p>dp真的是一个很恐怖的东西ORZ。</p><p>此解法非唯一解，且不一定是最好的解法，如果您有更好的解法，欢迎在评论区中提出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="技术" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="算法" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"/>
    
    <category term="学习日志" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="C++" scheme="https://blog.joyer.top/tags/C/"/>
    
    <category term="算法" scheme="https://blog.joyer.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://blog.joyer.top/tags/LeetCode/"/>
    
    <category term="思维" scheme="https://blog.joyer.top/tags/%E6%80%9D%E7%BB%B4/"/>
    
    <category term="动态规划" scheme="https://blog.joyer.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="dp" scheme="https://blog.joyer.top/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode每日一题 653. 两数之和 IV - 输入 BST</title>
    <link href="https://blog.joyer.top/2022-03-21/"/>
    <id>https://blog.joyer.top/2022-03-21/</id>
    <published>2022-03-21T00:59:27.000Z</published>
    <updated>2022-04-17T09:36:45.675Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>今天是一道简单题，来看题目<a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/">LeetCode 653. 两数之和 IV - 输入 BST</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个二叉搜索树 root 和一个目标结果 k，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例1：<br><img src="https://assets.leetcode.com/uploads/2020/09/21/sum_tree_1.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [5,3,6,2,4,null,7], k = 9</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>示例2：<br><img src="https://assets.leetcode.com/uploads/2020/09/21/sum_tree_2.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [5,3,6,2,4,null,7], k = 28</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>题目很简单，一看就懂。</p><p>先简单介绍一下BST，BST是满足以下三个条件的二叉树：</p><ol><li><p>节点的左子树包含的节点的值小于该节点的值</p></li><li><p>节点的右子树包含的节点的值大于等于该节点的值</p></li><li><p>节点的左子树和右子树都是BST  </p><p><img src="https://assets.leetcode.com/uploads/2020/09/21/sum_tree_1.jpg"><br>接下来介绍两种解法。</p></li></ol><h2 id="BST特性：中序遍历-双指针"><a href="#BST特性：中序遍历-双指针" class="headerlink" title="BST特性：中序遍历 + 双指针"></a>BST特性：中序遍历 + 双指针</h2><p>因为是BST，所以直接使用中序遍历能够转换成有序数组，进而能够使用双指针。</p><p>先把整个二叉树通过中序遍历加入到数组 <code>nums</code> 中，然后对其用双指针 <code>nums[l] + nums[r]</code> 计算出值与 <code>k</code> 对比大小:</p><ul><li>如果 <code>nums[l] + nums[r] &gt; k</code> 则 <code>r--</code>  </li><li>如果 <code>nums[l] + nums[r] &lt; k</code> 则 <code>l++</code></li><li>如果 <code>nums[l] + nums[r] == k</code> 则 <code>return true</code></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行 32 ms 超越 81.55%  消耗 35.9 MB 超越 75.94%</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">BSTout</span>(root);</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">while</span>(l!=r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[l]+nums[r]&gt;k)</span><br><span class="line">                r--;</span><br><span class="line">            <span class="keyword">if</span>(nums[l]+nums[r]&lt;k)</span><br><span class="line">                l++;</span><br><span class="line">            <span class="keyword">if</span>(l!=r&amp;&amp;nums[l]+nums[r]==k)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BSTout</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">BSTout</span>(root-&gt;left);</span><br><span class="line">        nums.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">BSTout</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="暴力：二叉树遍历-hash-判断"><a href="#暴力：二叉树遍历-hash-判断" class="headerlink" title="暴力：二叉树遍历 + hash 判断"></a>暴力：二叉树遍历 + hash 判断</h2><p>直接对二叉树遍历，然后将其加入set中,如果发现 <code>set.find(k - val)!=map.end()</code> 成立,则直接 <code>return ture</code>,反之遍历完二叉树后 <code>return false</code>，十分简单粗暴。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行 36 ms 超越 67.15%  消耗 37.8 MB 超越 36.32%</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">find</span>(k-root-&gt;val)!=nums.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        nums.<span class="built_in">insert</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findTarget</span>(root-&gt;left,k) || <span class="built_in">findTarget</span>(root-&gt;right,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="PS"><a href="#PS" class="headerlink" title="PS:"></a>PS:</h1><p>轻松愉快地完成了本次每日一题。  </p><p>国际惯例：<br>此解法非唯一解，且不一定是最好的解法，如果您有更好的解法，欢迎在评论区中提出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="技术" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="算法" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"/>
    
    <category term="学习日志" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="C++" scheme="https://blog.joyer.top/tags/C/"/>
    
    <category term="算法" scheme="https://blog.joyer.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://blog.joyer.top/tags/LeetCode/"/>
    
    <category term="递归" scheme="https://blog.joyer.top/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="BST" scheme="https://blog.joyer.top/tags/BST/"/>
    
    <category term="双指针" scheme="https://blog.joyer.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>经历了一点小挫折以后，我突然开始理解了抽烟喝酒</title>
    <link href="https://blog.joyer.top/2022-03-20-2/"/>
    <id>https://blog.joyer.top/2022-03-20-2/</id>
    <published>2022-03-20T10:39:08.000Z</published>
    <updated>2022-04-15T05:27:53.076Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>今天做题的时候脑子简直就搅成了一团浆糊，看着题头晕脑涨，突然心中冒出来个想法，“抽支烟冷静一下吧”，让我打了打冷颤。</p><p>虽然我平时偶尔会自己为自己来杯酒陶醉一番，但我并不抽烟。因为自小以来长辈的教育，以及本身也深知吸烟有害，所以我根本就不碰烟，平时拒绝掉朋友的烟，还会被白眼称为“小朋友”。</p><p>不理解为什么烟民们会非常习惯性的下意识抽一支烟，在以前就我看来其实仅仅是烟瘾。 但今天我对此发生了改观，原因就是我突然也想抽一支（。为了赶快将这个奇怪的念头压下去，我拿出了咖啡，却发现居然只剩下一包了……快速地烧了壶开水，打开包装给自己滤了杯咖啡，一口入嘴，豆子那股草本味就在我口腔中爆发出来，让我清醒不少……突然发现，手中的咖啡就如同烟民们手中那根烟一样，我豁然开朗，解开了“下意识地抽一支烟”这个疑惑。它根本就不是能够解释得出来的一件事，就是这样般、本该这样般地自然而然的事。<br><img src="https://blog.joyer.top/2022-03-20-2/1.jpg"><br>或许我也真的需要一根烟来帮助我思考问题，在一筹莫展的时候，抽一支烟换换心情，或许能够走出死胡同找到答案。</p><p>但我依旧不会去因此而抽烟，哈哈哈。</p><p>但我要去买咖啡了，下一篇文章见。 <img src="https://bu.dusays.com/2021/01/15/1c131772d1bb2.png" alt="滑稽"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="杂谈" scheme="https://blog.joyer.top/categories/%E6%9D%82%E8%B0%88/"/>
    
    <category term="瞎叭叭" scheme="https://blog.joyer.top/categories/%E6%9D%82%E8%B0%88/%E7%9E%8E%E5%8F%AD%E5%8F%AD/"/>
    
    
    <category term="杂谈" scheme="https://blog.joyer.top/tags/%E6%9D%82%E8%B0%88/"/>
    
    <category term="瞎叭叭" scheme="https://blog.joyer.top/tags/%E7%9E%8E%E5%8F%AD%E5%8F%AD/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode每日一题 2039. 网络空闲的时刻</title>
    <link href="https://blog.joyer.top/2022-03-20-1/"/>
    <id>https://blog.joyer.top/2022-03-20-1/</id>
    <published>2022-03-20T07:52:26.000Z</published>
    <updated>2022-04-17T09:36:45.683Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>今天的题目是<a href="https://leetcode-cn.com/problems/the-time-when-the-network-becomes-idle/">LeetCode 2039. 网络空闲的时刻</a> ，令我产生多个思考，来看题目。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个有 n 个服务器的计算机网络，服务器编号为 <code>0</code> 到 <code>n - 1</code> 。同时给你一个二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ui, vi]</code> 表示服务器 <code>ui</code> 和 <code>vi</code> 之间有一条信息线路，在 <strong>一秒</strong> 内它们之间可以传输 <strong>任意</strong> 数目的信息。再给你一个长度为 <code>n</code> 且下标从 <strong>0</strong> 开始的整数数组 <code>patience</code> 。</p><p>题目保证所有服务器都是 <strong>相通</strong> 的，也就是说一个信息从任意服务器出发，都可以通过这些信息线路直接或间接地到达任何其他服务器。</p><p>编号为 <code>0</code> 的服务器是 <strong>主</strong> 服务器，其他服务器为 <strong>数据</strong> 服务器。每个数据服务器都要向主服务器发送信息，并等待回复。信息在服务器之间按 <strong>最优线路</strong> 传输，也就是说每个信息都会以 <strong>最少时间</strong> 到达主服务器。主服务器会处理 <strong>所有</strong> 新到达的信息并 <strong>立即</strong> 按照每条信息来时的路线 <strong>反方向</strong> 发送回复信息。</p><p>在 <strong>0</strong> 秒的开始，所有数据服务器都会发送各自需要处理的信息。从第 <strong>1</strong> 秒开始，每 一秒最 <strong>开始</strong> 时，每个数据服务器都会检查它是否收到了主服务器的回复信息（包括新发出信息的回复信息）：</p><ul><li>如果还没收到任何回复信息，那么该服务器会周期性 重发 信息。数据服务器 <code>i</code> 每 <code>patience[i]</code> 秒都会重发一条信息，也就是说，数据服务器 i 在上一次发送信息给主服务器后的 <code>patience[i]</code> 秒 后 会重发一条信息给主服务器。</li><li>否则，该数据服务器 <strong>不会重发</strong> 信息。</li></ul><p>当没有任何信息在线路上传输或者到达某服务器时，该计算机网络变为 <strong>空闲</strong> 状态。</p><p>请返回计算机网络变为 <strong>空闲</strong> 状态的 <strong>最早秒数</strong> 。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例1：<br><img src="https://assets.leetcode.com/uploads/2021/09/22/quiet-place-example1.png" alt="来自LeetCode"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">输入：edges = [[0,1],[1,2]], patience = [0,2,1]</span><br><span class="line">输出：8</span><br><span class="line">解释：</span><br><span class="line">0 秒最开始时，</span><br><span class="line">- 数据服务器 1 给主服务器发出信息（用 1A 表示）。</span><br><span class="line">- 数据服务器 2 给主服务器发出信息（用 2A 表示）。</span><br><span class="line"></span><br><span class="line">1 秒时，</span><br><span class="line">- 信息 1A 到达主服务器，主服务器立刻处理信息 1A 并发出 1A 的回复信息。</span><br><span class="line">- 数据服务器 1 还没收到任何回复。距离上次发出信息过去了 1 秒（1 &lt; patience[1] = 2），所以不会重发信息。</span><br><span class="line">- 数据服务器 2 还没收到任何回复。距离上次发出信息过去了 1 秒（1 == patience[2] = 1），所以它重发一条信息（用 2B 表示）。</span><br><span class="line"></span><br><span class="line">2 秒时，</span><br><span class="line">- 回复信息 1A 到达服务器 1 ，服务器 1 不会再重发信息。</span><br><span class="line">- 信息 2A 到达主服务器，主服务器立刻处理信息 2A 并发出 2A 的回复信息。</span><br><span class="line">- 服务器 2 重发一条信息（用 2C 表示）。</span><br><span class="line">...</span><br><span class="line">4 秒时，</span><br><span class="line">- 回复信息 2A 到达服务器 2 ，服务器 2 不会再重发信息。</span><br><span class="line">...</span><br><span class="line">7 秒时，回复信息 2D 到达服务器 2 。</span><br><span class="line"></span><br><span class="line">从第 8 秒开始，不再有任何信息在服务器之间传输，也不再有信息到达服务器。</span><br><span class="line">所以第 8 秒是网络变空闲的最早时刻。</span><br></pre></td></tr></table></figure><p>示例2：<br><img src="https://assets.leetcode.com/uploads/2021/09/04/network_a_quiet_place_2.png" alt="leetCode"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：edges = [[0,1],[0,2],[1,2]], patience = [0,10,10]</span><br><span class="line">输出：3</span><br><span class="line">解释：数据服务器 1 和 2 第 2 秒初收到回复信息。</span><br><span class="line">从第 3 秒开始，网络变空闲。</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>今天的题目那是十分之长，看吐了，谢谢你 LeetCode。</p><p>看完后第一反应就是广搜（BFS），从主服务器 0 开始向四周搜索所有子服务器的 <strong>最短路径</strong> 。</p><blockquote><p>如果不理解广搜可以先看看我以前的BFS相关文章 <a href="https://blog.joyer.top/2021-12-07-1/">LeetCode每日一题 1034. 边界着色</a></p></blockquote><p>获得最短路径之后我们开始计算每一个服务器从 <strong>第一次</strong> 发信到 <strong>最后一次</strong> 收到回信之间的时间，在这些服务器中耗时最长的即是本题答案：“计算机网络变为 <strong>空闲</strong> 状态的 <strong>最早秒数</strong> ” 。</p><p>我们已知 服务器 <code>n</code> 的重复发信周期为 <code>patience[n]</code> 秒，以及通过上文提到的搜索计算出来的服务器 <code>n</code> 到服务器 <code>n</code> 的最短通信时间 <code>server_time</code> 秒。</p><p>这里会分为两种情况：</p><ul><li><code>patience[n] &gt;= server_time</code>：当服务器 <code>n</code> 收到它第一次发信的回信后，重复发信周期还未到；或是因为收信优先级高于发信，还没来得及发信就收到了第一次的发信，打断了下一次的发信，这个时候就已经完成了这个服务器的整个收发动作，网络中也不再存在来自此服务器的数据或是发送给此服务器的数据，则一次收发动作 <code>server_time*2 + 1</code> 就是 服务器 <code>n</code> 的整个 “变为空闲状态的最早秒数”。</li><li><code>patience[n] &lt; server_time</code>：当服务器 <code>n</code> 还未收到它第一次发信的回信时就已触发了重复发信周期，这个时候在它收到第一次发信的回信后，整个网络中还存在着 <code>(time * 2-1) /patience[n]</code> 个关于这个服务器 <code>n</code> 的 数据，此时这个服务器还将继续收信不能变为空闲状态，所以当达到服务器 <code>n</code> 的整个 “变为空闲状态的最早秒数” 应该是 <code>server_time*2 + patience[n]*((time * 2-1) /patience[n]) + 1</code>。</li></ul><p>然而当 <code>patience[n] &gt;= server_time</code> 时 <code>patience[n]*((time * 2-1) /patience[n])==0</code>, 所以以上两个条件的公式可以复用为 <code>server_time*2 + patience[n]*((time * 2-1) /patience[n]) + 1</code>。</p><p>由于本人思路不及他人，所以以上题解思路来自于 <a href="https://leetcode-cn.com/problems/the-time-when-the-network-becomes-idle/solution/wang-luo-kong-xian-de-shi-ke-by-leetcode-qttv/">LeetCode 官方题解</a> ，如果您有兴趣看一看我的思路请翻到 <a href="https://blog.joyer.top/2022-03-20-1/#PS">我的思路</a>。</p><p>开始写代码吧。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行 680 ms 超越 9.48%  消耗 198.4 MB 超越 26.72%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">networkBecomesIdle</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="keyword">int</span>&gt;&amp; patience)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">visit</span><span class="params">(patience.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">edges_map</span>(patience.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:edges)</span><br><span class="line">        &#123;</span><br><span class="line">            edges_map[i[<span class="number">0</span>]].<span class="built_in">push_back</span>(i[<span class="number">1</span>]);</span><br><span class="line">            edges_map[i[<span class="number">1</span>]].<span class="built_in">push_back</span>(i[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        visit[<span class="number">0</span>]=<span class="literal">true</span>; <span class="comment">//主服务器去除</span></span><br><span class="line">        <span class="keyword">int</span> max_time=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> time=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> qsize=que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;qsize;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i:edges_map[que.<span class="built_in">front</span>()])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!visit[i])</span><br><span class="line">                    &#123;</span><br><span class="line">                        que.<span class="built_in">emplace</span>(i);</span><br><span class="line">                        max_time=<span class="built_in">max</span>(time*<span class="number">2</span> + patience[i]*((time*<span class="number">2</span><span class="number">-1</span>) / patience[i]),max_time);</span><br><span class="line">                        visit[i]=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            time++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_time+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>理解官方思路后重新写了代码，但都无法追上官方的成绩，思考了一下午的时间，还是放弃……如果有大佬路过看到此篇能提供帮助小辈万分感谢。<br><img src="https://blog.joyer.top/2022-03-20-1/1.png"><br>实际上我的思路与官方的大差不差，但在实现方法上有不同。<br>来看整个代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;<span class="keyword">int</span>,set&lt;<span class="keyword">int</span>&gt;&gt; edges_map;  <span class="comment">//使用map与set会浪费空间，所以尽量使用vector</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; server_lenght;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">networkBecomesIdle</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="keyword">int</span>&gt;&amp; patience)</span> </span>&#123;</span><br><span class="line">        server_lenght.<span class="built_in">resize</span>(patience.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:edges)</span><br><span class="line">        &#123;</span><br><span class="line">            edges_map[i[<span class="number">0</span>]].<span class="built_in">insert</span>(i[<span class="number">1</span>]);</span><br><span class="line">            edges_map[i[<span class="number">1</span>]].<span class="built_in">insert</span>(i[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max_time=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">find_server</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;server_lenght.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(server_lenght[i]*<span class="number">2</span> % patience[i] == <span class="number">0</span>)</span><br><span class="line">                max_time = <span class="built_in">max</span>(server_lenght[i]*<span class="number">4</span> - patience[i],max_time);</span><br><span class="line">                <span class="comment">//从第0秒开始发信，到第 server_lenght[i]*2 秒收到回信时，此服务器最后一条信息已开始 server_lenght[i]*2 % patience[i] 秒</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(server_lenght[i]*<span class="number">2</span> &gt; patience[i])</span><br><span class="line">                max_time = <span class="built_in">max</span>(server_lenght[i]*<span class="number">4</span> - (server_lenght[i]*<span class="number">2</span> % patience[i]),max_time);</span><br><span class="line">                <span class="comment">//当出现 server_lenght[i]*2 % patience[i] == 0 条件时服务器的第一次发信已收到回信，则还在第 0 秒的最后一条发信停止发信</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                max_time = <span class="built_in">max</span>(server_lenght[i]*<span class="number">2</span>,max_time);</span><br><span class="line">                <span class="comment">//如果 patience[i] &gt; server_lenght[i]*2 , 此时服务器还尚未发信</span></span><br><span class="line">            cout&lt;&lt;server_lenght[i]&lt;&lt;endl;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> max_time+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find_server</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> sl)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:edges_map[n])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(server_lenght[i]&lt;=sl+<span class="number">1</span> &amp;&amp; server_lenght[i]!=<span class="number">0</span>) <span class="comment">//防止回环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(server_lenght[i]==<span class="number">0</span> || server_lenght[i]&gt;sl+<span class="number">1</span>)</span><br><span class="line">                server_lenght[i]=sl+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">find_server</span>(i,sl+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我对于此题的理解是：</p><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>对于这个BFS，我使用的是递归的方式先求出所有的数据服务器到主服务器的最短路径，再遍历计算变为休眠的时间。这样会造成偏离一整个数组的时间浪费，如果整合到一块会节省平均 500ms 的时间。</p><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>沿用上面提到的几个已知量 <code>server_time</code> 与 <code>patience[n]</code>，讨论一下 <code>patience[n] &lt; server_time</code> 这个情况。  </p><blockquote><p>当服务器<code>n</code>的首次发信收到回复时，距离服务器 <code>n</code> 最后一次发信的时间已过 <code>server_time*2%patience[n]</code> 秒，则此时这个信号将在 <code>server_time*2 - server_time*2%patience[n]</code> 秒后被服务器 <code>n</code> 收信。</p></blockquote><p>思路其实是没有问题的，但麻烦在这个公式本身有问题 —— 它不能像官方题解中的公式一样融合为一个公式，所以需要条件判断。</p><ul><li>当 <code>patience[n] &lt; server_time</code> 时……</li><li>当 <code>server_time % patience[n] = 0</code> 时……</li><li>当 <code>patience[n] &gt; server_time</code> 时……</li></ul><p>三个条件语句足以让本来有已经有了三个循环嵌套的程序代码执行时间平均增加 500 ms，所以这个思路事实上是不建议的。</p><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>由此题引发的反思。</p><p>以目前的情况来看，我虽然已经能够独立解决一些题目，但仍然欠缺不少地方。</p><p>对于算法来说，不仅仅是个人将算法记下来就可以了，而是需要将其转化运用到实际开发中。在算法的练习中需要时刻注意灵活运用，避免死板套公式，并且还需要注意在有限的时间空间内得到解决方案，不能滥用空间时间。</p><p>最后国际惯例：</p><p>此解法非唯一解，且不一定是最好的解法，如果您有更好的解法，欢迎在评论区中提出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="技术" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="算法" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"/>
    
    <category term="学习日志" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="C++" scheme="https://blog.joyer.top/tags/C/"/>
    
    <category term="算法" scheme="https://blog.joyer.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://blog.joyer.top/tags/LeetCode/"/>
    
    <category term="广度搜索" scheme="https://blog.joyer.top/tags/%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
    <category term="BFS" scheme="https://blog.joyer.top/tags/BFS/"/>
    
    <category term="递归" scheme="https://blog.joyer.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode每日一题 606. 根据二叉树创建字符串</title>
    <link href="https://blog.joyer.top/2022-03-19-1/"/>
    <id>https://blog.joyer.top/2022-03-19-1/</id>
    <published>2022-03-19T02:19:36.000Z</published>
    <updated>2022-04-15T05:24:51.594Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>早上好各位，今天起的很早就打开了LeetCode，让我们开始吧。</p><p><a href="https://leetcode-cn.com/problems/construct-string-from-binary-tree/">LeetCode 606. 根据二叉树创建字符串</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。</p><p>空节点则用一对空括号 “()” 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: 二叉树: [1,2,3,4]</span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     3</span><br><span class="line">   /    </span><br><span class="line">  4     </span><br><span class="line"></span><br><span class="line">输出: &quot;1(2(4))(3)&quot;</span><br><span class="line"></span><br><span class="line">解释: 原本将是“1(2(4)())(3())”，</span><br><span class="line">在你省略所有不必要的空括号对之后，</span><br><span class="line">它将是“1(2(4))(3)”。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: 二叉树: [1,2,3,null,4]</span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     3</span><br><span class="line">     \  </span><br><span class="line">      4 </span><br><span class="line"></span><br><span class="line">输出: &quot;1(2()(4))(3)&quot;</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>题目做多了后，一看就是递归。</p><p>我们把要输出的 <code>string</code> 提取出来写出公式：<br><code>root-&gt;val(root-&gt;left)(root-&gt;right)</code></p><p>一目了然。</p><p>再将递归方法套进去</p><p><code>root-&gt;val(tree2str(root-&gt;left))(tree2str(root-&gt;right))</code></p><p>当然还有其他条件了。</p><ul><li>当 <code>root-&gt;right == nullptr</code> 时我们要省略掉 <code>root-&gt;right</code> 的括号,如下：<br><code>root-&gt;val(tree2str(root-&gt;left))</code></li><li>当 <code>root-&gt;right==nullptr &amp;&amp; root-&gt;left==nullptr</code> 时我们就只需要返回 <code>root-&gt;val</code> </li><li>当 <code>root == nullptr</code> 时我们只需要返回空字符串 “”</li></ul><p>这样我们才算真正地完成了对题目的解读，可以开始写代码了。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行 12 ms 超越 90.28%  消耗 25.5 MB 超越 49.86%</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">tree2str</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right==<span class="literal">nullptr</span> &amp;&amp; root-&gt;left==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">to_string</span>(root-&gt;val)+<span class="string">&quot;(&quot;</span>+<span class="built_in">tree2str</span>(root-&gt;left)+<span class="string">&quot;)&quot;</span>+<span class="string">&quot;(&quot;</span>+<span class="built_in">tree2str</span>(root-&gt;right)+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">to_string</span>(root-&gt;val)+<span class="string">&quot;(&quot;</span>+<span class="built_in">tree2str</span>(root-&gt;left)+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>简单！</p><h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><p>此解法非唯一解，且不一定是最好的解法，如果您有更好的解法，欢迎在评论区中提出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="技术" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="算法" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"/>
    
    <category term="学习日志" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="C++" scheme="https://blog.joyer.top/tags/C/"/>
    
    <category term="算法" scheme="https://blog.joyer.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://blog.joyer.top/tags/LeetCode/"/>
    
    <category term="递归" scheme="https://blog.joyer.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode加练 6. Z 字形变换</title>
    <link href="https://blog.joyer.top/2022-03-18-2/"/>
    <id>https://blog.joyer.top/2022-03-18-2/</id>
    <published>2022-03-18T12:17:00.000Z</published>
    <updated>2022-04-15T05:26:38.378Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>不知道用什么顶部图了，直接套用每日一题的好了。<br>今天加练的原因是前一道题实在不咋地，思来想去再做一题罢，<a href="https://leetcode-cn.com/problems/zigzag-conversion/">LeetCode 6. Z 字形变换</a> 。<br>来看题目。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure><p>##示例<br>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><br><span class="line">输出：&quot;PAHNAPLSIIGYIR&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class="line">输出：&quot;PINALSIGYAHRPI&quot;</span><br><span class="line">解释：</span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;A&quot;, numRows = 1</span><br><span class="line">输出：&quot;A&quot;</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>模拟！是模拟！我突然发现我已经做了两三天模拟了x。其实关于这道题我们只需要找到其中的规律即可，我们来看看这个所谓的 “z字形排列”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@   @   @       0     8           16</span><br><span class="line">@  @@  @@       1   7 9        15 17</span><br><span class="line">@ @ @ @ @       2  6  10    14    18</span><br><span class="line">@@  @@  @       3 5   11 13       19</span><br><span class="line">@   @   @       4     12          20</span><br></pre></td></tr></table></figure><p>就是这样的排列，然后我们需要按行来输出，用下标来表示：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 8 16 1 7 9 15 17 2 6 10 14 18 3 5 11 13 19 4 12 20</span><br></pre></td></tr></table></figure><p>看出什么情况了吗？<br>让我们再简化一下这该死的阵列。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@ @ @     0   8     16</span><br><span class="line">@@@@@     1 7 9  15 17</span><br><span class="line">@@@@@     2 6 10 14 18</span><br><span class="line">@@@@@     3 5 11 13 19</span><br><span class="line">@ @ @     4   12    20</span><br></pre></td></tr></table></figure><p>和前面是一样的，这次呢？<br>看出来了吧。<br>第一行的情况：<br><code>8 - 0 = 8</code> <code>16 - 8 = 8</code><br>和它们同列的情况：<br><code>9 - 1 = 8</code> <code>10 - 2 = 8</code><br><code>11 - 3 = 8</code> <code>20 - 12 = 8</code><br>他们都在长列。</p><p>那短列的情况呢？<br><code>15 - 7 = 8</code> <code>14 - 6 = 8</code><br>它们也相差 8 。</p><p>我们得出结论，它们隔一列的下标都差 8 。</p><p>换个 numRows = 3 看看？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@ @ @       0   4   8</span><br><span class="line">@@@@@       1 3 5 7 9</span><br><span class="line">@ @ @       2   6   10</span><br></pre></td></tr></table></figure><p>情况好像不太一样了，这次隔列相差 4 ，怎么会这样？这个隔列相差 x 个单位肯定与 numberRows 有关系。  </p><p>稍微计算一下可以发现 <code>x = 2 ( numberRows - 1 )</code>,您看看是不是这样？</p><p>直接清晰明了了有没有！</p><p>虽然我们的第0，2，4，……列能够计算了，但是1，3，5，……怎么办呢？我们只要知道第 1 列的元素下标就能算出剩下的了。</p><p>再观察一下可以发现是 ``x = 2(numberRows-n-1)’’ （这里的 n 是第 n 行），我们发现变量以后计算公式就方便多了。</p><p>可以开始写代码了。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numRows==<span class="number">1</span> || numRows&gt;s.<span class="built_in">size</span>()) <span class="comment">//当出现这两种情况时只需要输出原 s</span></span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">        string ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>,k1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ans.<span class="built_in">size</span>()&lt;s.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=s[k];</span><br><span class="line">            k+=<span class="number">2</span>*(numRows<span class="number">-1</span>);  <span class="comment">//指向长列的下一个下标</span></span><br><span class="line">            <span class="keyword">if</span>(n&lt;numRows<span class="number">-1</span> &amp;&amp; n&gt;<span class="number">0</span> &amp;&amp;k1&lt;s.<span class="built_in">size</span>())<span class="comment">//当 n&lt;1 且 n&gt;numRows 时有短列参与</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans+=s[k1]; </span><br><span class="line">                k1+=<span class="number">2</span>*(numRows<span class="number">-1</span>); <span class="comment">//指向短列的下一个下标</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;=s.<span class="built_in">size</span>()) <span class="comment">//当每行的下标都超出了s.size() 我们就知道该轮到下一行了</span></span><br><span class="line">            &#123;</span><br><span class="line">                n++,k=n,k1=n+<span class="number">2</span>*(numRows-n<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><p>简单吧！我想了一下午！（</p><p>我发现这个题目有非常多的公式可以计算出下标结果，所以会有很多种解法，我这个只是其中一种解法，有不同见解欢迎下方讨论！</p><p>刷题惯例：</p><p>此解法非唯一解，且不一定是最好的解法，如果您有更好的解法，欢迎在评论区中提出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="技术" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="算法" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"/>
    
    <category term="学习日志" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="C++" scheme="https://blog.joyer.top/tags/C/"/>
    
    <category term="算法" scheme="https://blog.joyer.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://blog.joyer.top/tags/LeetCode/"/>
    
    <category term="模拟" scheme="https://blog.joyer.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode每日一题 2043. 简易银行系统</title>
    <link href="https://blog.joyer.top/2022-03-18-1/"/>
    <id>https://blog.joyer.top/2022-03-18-1/</id>
    <published>2022-03-18T08:07:17.000Z</published>
    <updated>2022-04-15T05:26:28.557Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p> <a href="https://leetcode-cn.com/problems/simple-bank-system/">LeetCode 2043. 简易银行系统</a> 虽说是一道普通题，但事实上其实是简单题，LeetCode 似乎特别喜欢把一些设计类题目写成普通题。<br>不是很想讲，但是踩了小坑，为了让我自己记住还是写一下吧。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>你的任务是为一个很受欢迎的银行设计一款程序，以自动化执行所有传入的交易（转账，存款和取款）。银行共有 <code>n</code> 个账户，编号从 <code>1</code> 到 <code>n</code> 。每个账号的初始余额存储在一个下标从 0 开始的整数数组 <code>balance</code>中，其中第 <code>(i + 1)</code> 个账户的初始余额是 <code>balance[i]</code> 。</p><p>请你执行所有 有效的 交易。如果满足下面全部条件，则交易 有效 ：</p><ul><li>指定的账户数量在 1 和 n 之间</li><li>取款或者转账需要的钱的总数 小于或者等于 账户余额。</li></ul><p>实现 Bank 类：</p><ul><li><code>Bank(long[] balance)</code> 使用下标从 <code>0</code> 开始的整数数组 <code>balance</code> 初始化该对象。</li><li><code>boolean transfer(int account1, int account2, long money)</code> 从编号为 <code>account1</code> 的账户向编号为 <code>account2</code> 的账户转帐 <code>money</code> 美元。如果交易成功，返回 <code>true</code> ，否则，返回 <code>false</code> 。</li><li><code>boolean deposit(int account, long money)</code> 向编号为 <code>account</code> 的账户存款 <code>money</code> 美元。如果交易成功，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li><li><code>boolean withdraw(int account, long money)</code> 从编号为 <code>account</code> 的账户取款 <code>money</code> 美元。如果交易成功，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;Bank&quot;, &quot;withdraw&quot;, &quot;transfer&quot;, &quot;deposit&quot;, &quot;transfer&quot;, &quot;withdraw&quot;]</span><br><span class="line">[[[10, 100, 20, 50, 30]], [3, 10], [5, 1, 20], [5, 20], [3, 4, 15], [10, 50]]</span><br><span class="line">输出：</span><br><span class="line">[null, true, true, true, false, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">Bank bank = new Bank([10, 100, 20, 50, 30]);</span><br><span class="line">bank.withdraw(3, 10);    // 返回 true ，账户 3 的余额是 $20 ，所以可以取款 $10 。</span><br><span class="line">                         // 账户 3 余额为 $20 - $10 = $10 。</span><br><span class="line">bank.transfer(5, 1, 20); // 返回 true ，账户 5 的余额是 $30 ，所以可以转账 $20 。</span><br><span class="line">                         // 账户 5 的余额为 $30 - $20 = $10 ，账户 1 的余额为 $10 + $20 = $30 。</span><br><span class="line">bank.deposit(5, 20);     // 返回 true ，可以向账户 5 存款 $20 。</span><br><span class="line">                         // 账户 5 的余额为 $10 + $20 = $30 。</span><br><span class="line">bank.transfer(3, 4, 15); // 返回 false ，账户 3 的当前余额是 $10 。</span><br><span class="line">                         // 所以无法转账 $15 。</span><br><span class="line">bank.withdraw(10, 50);   // 返回 false ，交易无效，因为账户 10 并不存在。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这道题就是从头到尾把各种操作操作模拟一次就可以了，主要要注意以下几点：</p><ul><li>账户必须存在于 <code>balance</code> 数组中，也就是说如果这个 account 超出 <code>balance</code> 的 size 就不存在这个账户，所有的操作方法都需要检查一次是否存在。</li><li><code>withdraw()</code> 中需要注意 money 不能够大于 balance[account-1] 。</li><li>在题目中没有讲清楚关于 <code>transfer()</code> 这个方法的具体运作。应该来说是不允许 account1 和 account2 相同的，这样等于说是自己给自己转钱了；但题目答案允许了这种操作，导致我的提交错了两次，哭笑不得了属于是。</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行 212 ms 超越 65.13% 消耗 114.1 MB 超越 41.21%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> &#123;</span></span><br><span class="line">    vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; balance_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bank</span>(vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&amp; balance) &#123;</span><br><span class="line">        balance_=balance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> account1, <span class="keyword">int</span> account2, <span class="keyword">long</span> <span class="keyword">long</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(account1==account2) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(balance_[account1<span class="number">-1</span>]&gt;=money) <span class="comment">//用两个判断来省略脱裤子放屁的步骤，实际提交中可以节省 50ms</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">withdraw</span>(account1,money))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">deposit</span>(account2,money))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                balance_[account1<span class="number">-1</span>]+=money;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> account, <span class="keyword">long</span> <span class="keyword">long</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(account<span class="number">-1</span>&gt;balance_.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        balance_[account<span class="number">-1</span>]+=money;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> account, <span class="keyword">long</span> <span class="keyword">long</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(account<span class="number">-1</span>&gt;balance_.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(balance_[account<span class="number">-1</span>]&lt;money)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        balance_[account<span class="number">-1</span>]-=money;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><p>请各位写代码的时候切记仔细检查代码错漏，我就是因为忘记在本题中 account 忘记减 1 导致提交错误了两次，在实际开发中出现这样的问题将可能会引发非常严重的错误，要以此引以为戒。</p><p>另外是真的很想吐槽 LeetCode 这样的题目，弄出这样脱裤子放屁的东西。</p><p>另外应该还可以缩减程序的执行时长，如果有会的大佬希望能够指点迷津。</p><p>最后是日常惯例：</p><p>此解法非唯一解，且不一定是最好的解法，如果您有更好的解法，欢迎在评论区中提出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="技术" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="算法" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"/>
    
    <category term="学习日志" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="C++" scheme="https://blog.joyer.top/tags/C/"/>
    
    <category term="算法" scheme="https://blog.joyer.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://blog.joyer.top/tags/LeetCode/"/>
    
    <category term="模拟" scheme="https://blog.joyer.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>每日一题LeetCode 720. 词典中最长的单词</title>
    <link href="https://blog.joyer.top/2022-03-17-2/"/>
    <id>https://blog.joyer.top/2022-03-17-2/</id>
    <published>2022-03-17T01:41:00.000Z</published>
    <updated>2022-04-15T05:26:12.078Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>今天的每日一题！<a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/">LeetCode 720. 词典中最长的单词</a>,想了很久，功夫还是不到家啊。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给出一个字符串数组 words 组成的一本英语词典。返回 words 中最长的一个单词，该单词是由 words 词典中其他单词逐步添加一个字母组成。</p><p>若其中有多个可行的答案，则返回答案中字典序最小的单词。若无答案，则返回空字符串。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;w&quot;,&quot;wo&quot;,&quot;wor&quot;,&quot;worl&quot;, &quot;world&quot;]</span><br><span class="line">输出：&quot;world&quot;</span><br><span class="line">解释： 单词&quot;world&quot;可由&quot;w&quot;, &quot;wo&quot;, &quot;wor&quot;, 和 &quot;worl&quot;逐步添加一个字母组成。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;a&quot;, &quot;banana&quot;, &quot;app&quot;, &quot;appl&quot;, &quot;ap&quot;, &quot;apply&quot;, &quot;apple&quot;]</span><br><span class="line">输出：&quot;apple&quot;</span><br><span class="line">解释：&quot;apply&quot; 和 &quot;apple&quot; 都能由词典中的单词组成。但是 &quot;apple&quot; 的字典序小于 &quot;apply&quot; </span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>很简单一个东西，结果给我想复杂了。<br>阅读题目，作为一个<code>words</code>中最长的一个字符串，它由<code>words</code>中其他单词逐步添加一个字母形成，那么这个字符串 word 的 <code>word.substr(0,word.size()-1))</code> 必定存在。</p><p>以示例一为例，<code>“world”.substr(0,&quot;world&quot;.size()-1) = &quot;worl&quot;</code>, 而 <code>“worl”.substr(0,&quot;worl&quot;.size()-1) = &quot;wor&quot;</code>,很好理解，我们就是要找这种类型的最长的字符串，所以我们只要检索这个字符串的<code>substr(0,word.size()-1))</code>是否存在于words中即可，如果这个字符串的所有“前导”全都存在，就记录进ans中。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="我写的代码"><a href="#我写的代码" class="headerlink" title="我写的代码"></a>我写的代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行 1260ms 超越5.26%   内存 25.2 MB 超越 45.15%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">longestWord</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),[](<span class="keyword">const</span> string &amp; a,<span class="keyword">const</span> string &amp; b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a.<span class="built_in">size</span>()!=b.<span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">return</span> a.<span class="built_in">size</span>()&gt;b.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">return</span> a&gt;b;</span><br><span class="line">        &#125;); <span class="comment">//从大到小排序，字典序靠前的向后移</span></span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:words)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> bl=<span class="literal">true</span>;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(ans.<span class="built_in">size</span>()&gt;i.<span class="built_in">size</span>()) <span class="comment">//当ans长度超过当前遍历到的字符串的长度后直接退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i.<span class="built_in">size</span>()<span class="number">-1</span>;j&gt;<span class="number">0</span>;j--) <span class="comment">//蠢蛋写法，每一个字符串都要再次从头开始遍历查询，消耗大量时间</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">find</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),i.<span class="built_in">substr</span>(<span class="number">0</span>,j))==words.<span class="built_in">end</span>()) </span><br><span class="line">                &#123;</span><br><span class="line">                    bl=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(bl)</span><br><span class="line">                ans=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>写完后其实不满意，耗时太高，于是看了官方的代码。笨蛋如我，居然没想到用 set 容器，按照官方做法可以节省下一大笔的时间花费和空间花费。</p><h2 id="官方做法"><a href="#官方做法" class="headerlink" title="官方做法"></a>官方做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestWord</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [](<span class="keyword">const</span> string &amp; a, <span class="keyword">const</span> string &amp; b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.<span class="built_in">size</span>() != b.<span class="built_in">size</span>()) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> a &gt; b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);  <span class="comment">//从小到大排序，字典序靠前的向后移</span></span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        set&lt;string&gt; cnt;</span><br><span class="line">        cnt.<span class="built_in">emplace</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> word : words) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt.<span class="built_in">count</span>(word.<span class="built_in">substr</span>(<span class="number">0</span>, word.<span class="built_in">size</span>() - <span class="number">1</span>))) &#123; <span class="comment">//当查到“前导”字符串即添加进set容器并保存进ans</span></span><br><span class="line">                cnt.<span class="built_in">emplace</span>(word);</span><br><span class="line">                ans = word;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><ul><li><p>简单题大翻车，重新认识到我自身到底有多菜，还要多多加油！</p></li><li><p>此解法非唯一解，且不一定是最好的解法，如果您有更好的解法，欢迎在评论区中提出。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="技术" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="算法" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"/>
    
    <category term="学习日志" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="C++" scheme="https://blog.joyer.top/tags/C/"/>
    
    <category term="算法" scheme="https://blog.joyer.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://blog.joyer.top/tags/LeetCode/"/>
    
    <category term="模拟" scheme="https://blog.joyer.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>MikuMikuDance 制作初体验，毫不掩饰地说，我看得性奋了</title>
    <link href="https://blog.joyer.top/2022-03-17-1/"/>
    <id>https://blog.joyer.top/2022-03-17-1/</id>
    <published>2022-03-16T21:58:37.000Z</published>
    <updated>2022-05-08T06:42:00.206Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>百般无聊刷着B站之际，一瞬之间突然想做个MMD玩玩，正巧以前有过一点点经验，说完就直接开干，以下是成果。</p><h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1><div style="position:relative; padding-bottom:75%; width:100%; height:0">    <iframe src="//player.bilibili.com/player.html?bvid=BV1Gb4y1p7Dg&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position:absolute; height: 100%; width: 100%;"></iframe></div><h1 id="关于MMD"><a href="#关于MMD" class="headerlink" title="关于MMD"></a>关于MMD</h1><p>MMD真的很好玩。从本人的体验来说，MMD 是我们这帮二刺螈爱好者表达对某个作品或是单个角色的喜爱然后创作出二创的最好的表达方式之一，不仅观看这些二创作品的观众能得到非常好的观感，对于二创作者自身都是一件成就感满满的事。</p><p>我直到昨天真正开始浅尝 MMD 的时候才发现 MMD 这个圈子是真的比我预想的规模还要庞大，有各种各样的社群网站资源网站来维护 MMD 这个庞大的圈子，并且也有属于这个圈子中人们不谋而合的规则来保护他们的圈子，在这个圈子里的每个人的愿望都如此纯粹（有点当年年轻的陈叔叔与他的 BiliBili 的感觉），就是为了自己喜欢的作品和角色去做这样的工作，他们制作的模型分镜特效甚至能够被免费分享，当然了不能用于商用，规则类似于我们这帮臭写代码的其中的代码开源规则。</p><p><img src="https://blog.joyer.top/2022-03-17-1/1.png" alt="发现新世界 BowlRoll"></p><p>我不禁感叹啊这东西太好了，让我仿佛回到了少年时期的那个夏天，空气都如此纯净。</p><p>稍微有点扯远了，做 MMD 当然不是一件简单的事，除了最基础的模型，你还得懂美术，得懂动作k帧，得懂场景渲染（就是那些shader之类的玩意），得会写分镜设计镜头语言，还得会视频制作……这么一套下来就一个人或者是几个人干真的超乎想象，但是关键人家又做得这么好！属实是为爱发电。</p><h1 id="做了一个-MMD！（拖更LeetCode的理由！）"><a href="#做了一个-MMD！（拖更LeetCode的理由！）" class="headerlink" title="做了一个 MMD！（拖更LeetCode的理由！）"></a>做了一个 MMD！<del>（拖更LeetCode的理由！）</del></h1><p>当然我也就是个门外汉，就只会套套大佬的模型、动作和镜头，自己做的话那是必然不可能，稍微学过一点皮毛的人都知道这玩意属实废精力。2000帧K个动作花费的时间真的很离谱。</p><p><img src="https://blog.joyer.top/2022-03-17-1/2.png" alt="MikuNikuDance 软件截图"><br>毫不掩饰地说，制作过程中我是真的看得<del>一度弟弟充血</del>，大佬做的表情和动作属实撩人，在此之前我认为我已经正式踏入现充门槛了，然而当我对此起反应之后，我不禁惊呼 “md我这不还是纯纯二刺螈嘛”，以及产生 “要和纸片人结婚” 的错觉，而后感叹 “啊纸片人真好啊，人生不就如此嘛”（。</p><p>很离谱，时过境迁我依旧还是那个热爱二刺螈的少年。</p><p>真就很离谱。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="杂谈" scheme="https://blog.joyer.top/categories/%E6%9D%82%E8%B0%88/"/>
    
    <category term="瞎叭叭" scheme="https://blog.joyer.top/categories/%E6%9D%82%E8%B0%88/%E7%9E%8E%E5%8F%AD%E5%8F%AD/"/>
    
    
    <category term="杂谈" scheme="https://blog.joyer.top/tags/%E6%9D%82%E8%B0%88/"/>
    
    <category term="MikuMikuDance" scheme="https://blog.joyer.top/tags/MikuMikuDance/"/>
    
    <category term="初音未来" scheme="https://blog.joyer.top/tags/%E5%88%9D%E9%9F%B3%E6%9C%AA%E6%9D%A5/"/>
    
    <category term="视频" scheme="https://blog.joyer.top/tags/%E8%A7%86%E9%A2%91/"/>
    
    <category term="模型" scheme="https://blog.joyer.top/tags/%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="动画" scheme="https://blog.joyer.top/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode每日一题 599. 两个列表的最小索引总和</title>
    <link href="https://blog.joyer.top/2022-03-14-1/"/>
    <id>https://blog.joyer.top/2022-03-14-1/</id>
    <published>2022-03-14T02:08:04.000Z</published>
    <updated>2022-04-11T01:40:26.118Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>LeetCode刷题坚持每一天！今天是摸鱼的一天！题目<a href="https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/">LeetCode 599. 两个列表的最小索引总和</a>.</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>假设 Andy 和 Doris 想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。</p><p>你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设答案总是存在。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: list1 = [&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;]，list2 = [&quot;Piatti&quot;, &quot;The Grill at Torrey Pines&quot;, &quot;Hungry Hunter Steakhouse&quot;, &quot;Shogun&quot;]</span><br><span class="line">输出: [&quot;Shogun&quot;]</span><br><span class="line">解释: 他们唯一共同喜爱的餐厅是“Shogun”。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入:list1 = [&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;]，list2 = [&quot;KFC&quot;, &quot;Shogun&quot;, &quot;Burger King&quot;]</span><br><span class="line">输出: [&quot;Shogun&quot;]</span><br><span class="line">解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这个题目让我纠结了很久，主要是“最少的索引和”这个字眼让我十分疑惑，翻了翻评论区得到解释 —— 两列表的下标和（看来还是我自己的理解能力不够哇/_ \），那么这样就说得通可以开始解题了。</p><p>整个题目意思其实就是让我们在最小下标和的情况下输出两个列表中同样的元素项目，也就是说我们既然能够输出下标和为 1 的答案，就不要输出下标和为 2 的答案，尽管下标和为 2 的元素比下标和为 1 的元素多。</p><p>那么我们就针对<code>list1</code>建立一个哈希表，每个元素内容作为 first，对应的 second 为<code>list1</code>中这个元素的下标； 而后我们可以开始循环遍历<code>list2</code>，当<code>list2</code>中的元素内容在哈希表中能找到，那么就计算<code>list1</code>此元素的下标与此元素在<code>list2</code>中对应的下标的和，然后对比 <code>vector&lt;string&gt; ans</code> 中的元素所指向的下标和，如果当前元素的下标和小于<code>ans</code>中元素的下标和，那么就直接清空ans并添加当前元素，但如果两元素的下标相等，那么就将其直接添加进数组<code>ans</code>中。</p><p>只需要这样，我们就能确定ans中的元素一定是我们需要的那些个。</p><p>那么开始写代码吧！</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行 100ms 超越23%   内存 35.8 MB 超越 78%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRestaurant</span><span class="params">(vector&lt;string&gt;&amp; list1, vector&lt;string&gt;&amp; list2)</span> </span>&#123;</span><br><span class="line">        map&lt;string,<span class="keyword">int</span>&gt; list1_;<span class="comment">//哈希表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list1.<span class="built_in">size</span>();i++)<span class="comment">//遍历输入哈希表</span></span><br><span class="line">            list1_[list1[i]]=i;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list2.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(list1_.<span class="built_in">find</span>(list2[i])!=list1_.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                list1_[list2[i]]+=i;  <span class="comment">//计算下标和</span></span><br><span class="line">                <span class="keyword">if</span>(ans.<span class="built_in">size</span>()==<span class="number">0</span>)  <span class="comment">//当ans中没有元素时直接添加</span></span><br><span class="line">                    ans.<span class="built_in">push_back</span>(list2[i]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(list1_[ans[<span class="number">0</span>]]&gt;list1_[list2[i]])  <span class="comment">//当ans中的元素在map中的下标和大于list2[i]时则清空替换</span></span><br><span class="line">                    ans.<span class="built_in">clear</span>(),ans.<span class="built_in">push_back</span>(list2[i]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(list1_[ans[<span class="number">0</span>]]==list1_[list2[i]]) <span class="comment">//当ans中的元素在map中的下标和等于list2[i]时则添加进ans</span></span><br><span class="line">                    ans.<span class="built_in">push_back</span>(list2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><p>此解法非唯一解，且不一定是最好的解法，如果您有更好的解法，欢迎在评论区中提出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="技术" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="算法" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"/>
    
    <category term="学习日志" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="C++" scheme="https://blog.joyer.top/tags/C/"/>
    
    <category term="算法" scheme="https://blog.joyer.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://blog.joyer.top/tags/LeetCode/"/>
    
    <category term="模拟" scheme="https://blog.joyer.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode每日一题 393. UTF-8 编码验证</title>
    <link href="https://blog.joyer.top/2022-03-13-2/"/>
    <id>https://blog.joyer.top/2022-03-13-2/</id>
    <published>2022-03-13T07:53:40.000Z</published>
    <updated>2022-04-11T01:40:26.149Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>久违的LeetCode每日一题又回来啦！，这一次是简单题！虽然表面上是普通题！来看题目！<a href="https://leetcode-cn.com/problems/utf-8-validation/">LeetCode 393. UTF-8 编码验证</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个表示数据的整数数组<code>data</code>，返回它是否为有效的 UTF-8 编码。</p><p>UTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则：</p><ol><li>对于 <code>1 字节</code> 的字符，字节的第一位设为 0 ，后面 7 位为这个符号的 unicode 码。</li><li>对于 <code>n 字节</code> 的字符 (n &gt; 1)，第一个字节的前 n 位都设为1，第 n+1 位设为 0 ，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。</li><li>这是 <code>UTF-8</code> 编码的工作方式：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Char. number range  |        UTF-8 octet sequence</span><br><span class="line">   (hexadecimal)    |              (binary)</span><br><span class="line">--------------------+---------------------------------------------</span><br><span class="line">0000 0000-0000 007F | 0xxxxxxx</span><br><span class="line">0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure></li></ol><p>注意：输入是整数数组。只有每个整数的 最低 8 个有效位 用来存储数据。这意味着每个整数只表示 1 字节的数据。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：data = [197,130,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：数据表示字节序列:11000101 10000010 00000001。</span><br><span class="line">这是有效的 utf-8 编码，为一个 2 字节字符，跟着一个 1 字节字符。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：data = [235,140,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：数据表示 8 位的序列: 11101011 10001100 00000100.</span><br><span class="line">前 3 位都是 1 ，第 4 位为 0 表示它是一个 3 字节字符。</span><br><span class="line">下一个字节是开头为 10 的延续字节，这是正确的。</span><br><span class="line">但第二个延续字节不以 10 开头，所以是不符合规则的。</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>先来读懂题目！<code>data</code> 中的每一个整数元素都代表着一个字节，题目要求我们判别用整数数组 <code>data</code> 来表示的一段编码流是否符合 UTF-8 编码标准， 先来说明 UTF-8 编码标准。</p><ol><li>作为一个 <code>1 字节</code> 字符的编码，前 1 位不能为 1 ，例如 <code>0100 0000</code> 、 <code>0100 1111</code>.</li><li>作为一个 <code>n 字节</code> 字符的编码，第一个字节的编码的前 n 位必须为 1 ，且第 n+1 位必须为 0 ，而后 n-1 个字节的编码必须是 10 开头， 例如  <code>1110 0000</code>  <code>1000 0000</code>  <code>1011 0000</code></li><li>UTF-8 编码最多只存在 4 字节字符。</li></ol><p>乍一看，我去怎么要搞二进制，心里就开始盘算起D转B那些个不想回忆的东西；不过当真正看懂题目后，其实是非常简单的，只要数组<code>data</code>没有以下提到的几个条件，那么它就是合规范的 UTF-8 编码。</p><ol><li>存在与前后字节无关系的前两位为 10 的字节，例如 <code>1100 1000</code> <code>1000 1000</code> <code>1000 0000</code>（前两个字节的编码为一个 <code>2 字节</code> 编码）。</li><li>存在作为一个 <code>n 字节</code> 编码的第二、三、四字节中一个字节及以上非 10 开头，例如 <code>1110 0000</code> <code>1000 0000</code> <code>1110 0000</code> 或 <code>1110 0000</code> <code>0000 0000</code> <code>1000 0000</code> 。</li><li>存在作为一个 <code>n 字节</code> 编码却缺失字节，例如 <code>1100 0000</code> (data.size()==1)。</li><li>存在从前往后数有超过五位数为1的单个字节，例如 <code>1111 1000</code> 。</li></ol><p>如果逃过了以上条件的<code>data</code>，那么它就一定是一串符合UTF-8编码的编码流。</p><p>在验证以上四点时，我们没必要一定将单个十进制整数元素转换成二进制再进行验证，那样计算太慢了，我们不妨反过来将几个二进制阈值手算转换为十进制进行验证。</p><p>如<code>1111 0000</code>转换成十进制是 240，或 <code>1000 0000</code>转换为十进制是 128，瞬间就变简单了有木有！ψ(｀∇´)ψ</p><p>于是让我们开始敲代码吧！</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2022/03/13 执行 8ms 超越 97.92%，内存 13.5MB 超越 88.43%</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validUtf8</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;data.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> count_=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(data[i]&gt;<span class="number">247</span>) <span class="comment">//字节超出4位即非法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(data[i]&lt;<span class="number">128</span>) <span class="comment">//1字节跳过</span></span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(data[i]&lt;<span class="number">192</span>) <span class="comment">//一字节前两位10即违法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(data[i]&gt;=<span class="number">240</span>) <span class="comment">//大于1111 0000 count++</span></span><br><span class="line">                count_++;</span><br><span class="line">            <span class="keyword">if</span>(data[i]&gt;=<span class="number">224</span>) <span class="comment">//大于1110 0000 count++</span></span><br><span class="line">                count_++;</span><br><span class="line">            <span class="keyword">if</span>(data[i]&gt;=<span class="number">192</span>) <span class="comment">//大于1100 0000 count++</span></span><br><span class="line">                count_++;</span><br><span class="line">            <span class="keyword">if</span>(count_+i&gt;data.<span class="built_in">size</span>()) <span class="comment">//字节超出数组范围即非法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;count_;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( data[i+j]&lt;<span class="number">128</span> || data[i+j]&gt;=<span class="number">192</span> )  <span class="comment">//在二三四字节前两位非10即非法</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i+=count_;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><p>此解法非唯一解，且不一定是最好的解法，如果您有更好的解法，欢迎在评论区中提出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="技术" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="算法" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"/>
    
    <category term="学习日志" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="C++" scheme="https://blog.joyer.top/tags/C/"/>
    
    <category term="算法" scheme="https://blog.joyer.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://blog.joyer.top/tags/LeetCode/"/>
    
    <category term="模拟" scheme="https://blog.joyer.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>摸鱼 弄了一个FF14相关的网页导航</title>
    <link href="https://blog.joyer.top/2022-03-13-1/"/>
    <id>https://blog.joyer.top/2022-03-13-1/</id>
    <published>2022-03-13T00:29:02.000Z</published>
    <updated>2022-03-13T00:58:30.853Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>昨天突发奇想想做一个ff14相关的导航，于是闲的蛋疼做了一个这样没卵用的网页导航。不过其实要说更实用的导航当然还是 <a href="https://www.ffxiv.cn/v2/">素素攻略站</a> 。</p><p><img src="https://joyerliii.github.io/2022-03-13-1/1.png"></p><p>权当是做了一个小练习吧x，我已经很久没有碰过 html 了。想要访问看一看的朋友可以从顶部导航栏直接进入（虽然内容一定会让人简陋到失望x）。</p><p>如果有朋友喜欢这样的导航当然就更好了，有什么建议或者意见可以在下方提出，有什么想加入的功能我会积极加入。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="技术" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="网页" scheme="https://blog.joyer.top/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E9%A1%B5/"/>
    
    
    <category term="HTML" scheme="https://blog.joyer.top/tags/HTML/"/>
    
    <category term="最终幻想14" scheme="https://blog.joyer.top/tags/%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B314/"/>
    
    <category term="游戏" scheme="https://blog.joyer.top/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="网页导航" scheme="https://blog.joyer.top/tags/%E7%BD%91%E9%A1%B5%E5%AF%BC%E8%88%AA/"/>
    
  </entry>
  
</feed>
