<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>兜兜转转兜兜--关于Android开发中 Fragment 生命周期 OnActivityCreated() 被弃用以及在 Fragment 监听按钮跳转页面</title>
      <link href="/2022-12-02/"/>
      <url>/2022-12-02/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>正在学习Android的路上，服完国内这帮老掉牙的技术教程了，个人本想在 Fragment 中实现页面的跳转，奈何却被绊倒在了监听按钮事件上。</p><h2 id="破事其一-OnActivityCreated-被弃用"><a href="#破事其一-OnActivityCreated-被弃用" class="headerlink" title="破事其一 OnActivityCreated()被弃用"></a>破事其一 OnActivityCreated()被弃用</h2><p>Fragment 的 OnActivityCreated() 方法早已不能使用，国内大部分抄来抄去的教程还在tmd用这个方法教！官方的意思是为了减少页面耦合性，这我能理解，在这个方法弃用之后官方给出了一个解决方案——即使用 Lifecycle 来监听 Activity 的 Created 状态，即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">requireActivity().getLifecycle().addObserver(<span class="keyword">new</span> LifecycleEventObserver() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> <span class="meta">@NotNull</span> LifecycleOwner source, <span class="meta">@NonNull</span> <span class="meta">@NotNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (event.getTargetState() == Lifecycle.State.CREATED) &#123;<span class="comment">//监听Activity的Created事件</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//这里写希望执行的代码段</span></span><br><span class="line"></span><br><span class="line">                    getLifecycle().removeObserver(<span class="keyword">this</span>);  <span class="comment">//删除观察者</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>将这一大串放在 Fragment 的 OnAttach() 中，当 Lifecycle 检测到 Fragment 的 Activity 创建流程有所变动，就能捕捉到并运行 onStateChanged() 。</p><h2 id="破事其二-过去的-Fragment-看不到未来的-Activity"><a href="#破事其二-过去的-Fragment-看不到未来的-Activity" class="headerlink" title="破事其二 过去的 Fragment 看不到未来的 Activity"></a>破事其二 过去的 Fragment 看不到未来的 Activity</h2><p>OnActivityCreated() 的问题确实解决了。但这有一个问题，我想要的效果是点击按钮后跳转到新的页面，而跳转这个动作需要执行 startActivity(Intent(Activity,NextAvtivity.class)) ,Intent 参数中的 Class 问题不大肯定有，但要怎么让过去的 Fragment 提供一个未来的 Activity 呢。</p><p>如下图所示，这是 Fragment 生命周期中能够被获取到的几个状态</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/08/31722863.jpg"></p><p>只有当 OnActivityCreated 时，Fragment 才能知晓可用的 Activity ，在此之前如果你使用 getActivity() 会回返 null ，所以我们在 ActivityCreated 之前的Fragment 中 getActivity() 的回返都会是 null 。</p><p>看着图思考，终于脑袋开窍，峰回路转。既然我不能在 OnActivityCreated,我使用下一条流程 OnStart() 不就行了嘛，因为追究 OnActivityCreated() 这破事，害的我完全钻进了牛角尖，老旧教程害人啊🤣。</p><p>所以我们只需要选择在 OnActivityCreated() 流程之后的 OnStart() 流程设置点击监听就ok了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();  <span class="comment">//在OnStart()设置控件的点击事件！</span></span><br><span class="line">    regOnClick();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">regOnClick</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    OptionView optionViewLog = (OptionView) getActivity().findViewById(R.id.logOption);</span><br><span class="line">    ;</span><br><span class="line">    optionViewLog.findViewById(R.id.optionList).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">            intent.setClass(getActivity(), LogActivity.class); </span><br><span class="line">            startActivity(intent); <span class="comment">//跳转！</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此这般，你就发现你的跳转能用了。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这篇教程是一边写一边思考一边码代码的，除了水水博客,也是为了整理思路，有任何纰漏，烦请大神指点。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>00后小屁孩的怀旧，爱华 T30 磁带机，真是又爱又恨</title>
      <link href="/2022-10-25/"/>
      <url>/2022-10-25/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博文所有的所有都得从我那天生日开始……当天我亲爱的舍友给我发来信息说想送我一个生日礼物，并展示手办图片给我看问我喜欢哪个，很感谢舍友有这份心，即使他也并不混二刺螈也知道我满桌的景品是初音未来。</p><p>在来回推辞拉扯之后我最终还是接受了来自舍友的礼物，总所周知我是一个不折不扣的轻音粉，所以为了不让他太过破费，我改成了一张轻音少女的翻录盘，也就是在第二集中众人一起在部室录下的这张盘子。<img src="https://blog.joyer.top/2022-10-25/IMG20220926165841.jpg"></p><p>想要这个盘子很久了，惊喜的是能够发现有翻录盘，就算是翻录事实上我其实也能接受。</p><h1 id="正文-跳进大坑的开始"><a href="#正文-跳进大坑的开始" class="headerlink" title="正文(跳进大坑的开始)"></a>正文(跳进大坑的开始)</h1><p>有了碟醋就想包盘饺子，于是我在二手平台瞎琢磨最终买下了一台爱华 T30。</p><p><img src="https://blog.joyer.top/2022-10-25/IMG20220929162509.jpg"></p><p>买爱华T30 主要还是为了两点：</p><ul><li>1、第一次碰磁带机，我想要功能更多的。</li><li>2、它至少得我能支付的起。</li></ul><p>如此如此这般这般这台磁带机最终来到了我的手中。</p><h2 id="它的一些功能"><a href="#它的一些功能" class="headerlink" title="它的一些功能"></a>它的一些功能</h2><p>在买磁带机的时候我是做了些功课。爱华 T30 有着杜比降噪（其实我买的时候还以为是杜比音效）、自动翻带（一般都会有）、均衡器（很少有），我没注意到的是它 TM 居然还能从一类带听到三类带（这个我可以以后再起一篇专门介绍磁带的分类）。最主要的还是它是砖机，而不是超薄机。</p><h3 id="关于体积（带速与机械按钮）"><a href="#关于体积（带速与机械按钮）" class="headerlink" title="关于体积（带速与机械按钮）"></a>关于体积（带速与机械按钮）</h3><p>可以看到这机器其实是比较大的，我的一只手完全握不下，这家伙巨大的原因主要是它的机芯占地方多，机芯其实是决定了磁带机走速稳不稳的一个重要因素，而其中的飞轮则担任了稳定带速的重要角色，电机的速率其实不是匀称的，受到外界的干扰或是电流自身的问题速率都会变化，不说有刷电机，无刷电机也是一样。对于磁带机来说带速是很重要的，稍微一点的带速变化都会放大到人的耳朵里导致听着不对。为了稳定速率，飞轮越大越重，转向惯量也就越大，那么速度变化也会越平缓（说得可能不太对，大抵原理是这样）。卡座有着超大的飞轮和超稳的转速是它相对磁带随身听更好的一部分原因。回到砖机上，这家伙由着大体量的优势自然也得到了更大的空间去塞飞轮，有着比超薄随身听更好的稳速。</p><p>另外一部分原因大家其实也能看得到，就是它是机械式按钮，这一部分也需要牺牲一些厚度。个人认为机械式按钮要比超薄机上的更好，一个自然是它的反馈来的更直接真实，应该有些朋友小时候放英语听力时有见过磁带机（这自然也是为啥我们这代能接触到磁带机），老师放听力时几个按钮轮着按，咔嚓~啪一声弹响是真的清脆又舒服），另外一个则是个人不太信任电控按钮，总觉得会坏以及难修。</p><h2 id="拿到手之后"><a href="#拿到手之后" class="headerlink" title="拿到手之后"></a>拿到手之后</h2><p>我虽然有注意买别人大佬打理好的机器，但是拿到手后效果还是不尽理想，人声听起来没啥问题，到了背景音就完了，幽怨上下跳动的音调简直就想卡通片里的果冻音效，或是鬼片里的幽灵音效。得，还是得自己打理。</p><h2 id="打理磁带机是一个大坑"><a href="#打理磁带机是一个大坑" class="headerlink" title="打理磁带机是一个大坑"></a>打理磁带机是一个大坑</h2><p>上边出现的现象其实就是颤音，究其原因就是带子在经过磁头时不老实，或上下乱动或忽快忽慢，导致磁头读到的信号不连续，所以是传动部分的原因。收集信息后，我总结了一下磁带的走带结构,有朋友需要的我也找来了该机型的机芯结构可以看看。</p><p>这个是我随手画的一图，不是很好看。看磁带的走向不难看出，想让磁带不老实乱晃，那么其原因可能就是压带轮形状变形了、主导轴歪了、皮带快不行了、甚至有可能是导带槽方向歪了。。所以大家在判断颤音问题的时候，其实建议能够开仓查看一下磁带机的运行情况，再做进一步的判断。</p><p>一般来说如果发现走带速度忽快忽慢的话，就得考虑更换牵动主导轴的皮带，很有可能皮带松了，或者摩擦力不一样导致打滑了。</p><p>如果发现走带不稳呢，就把磁带拿出来，开仓空转一下查看主导轴是否歪了（这是非常要命的，歪一点点都不行！），静止状态下主导轴歪曲肉眼不容易看出来，当旋转起来后就非常明显了；如果主导轴真的没歪，那就很可能是压带轮了，更换压带轮吧朋友，没有办法。</p><p>当然了，也不能排除磁带的问题，一些磁带过于老旧或使用过多或本身质量不行，由于物理变形导致声像的变形。</p><p>我还找到了爱华 T30 的维修手册，如果有需要可以直达 <a href="https://blog.joyer.top/aiwa_hs-t30_sm.pdf">爱华T30维修手册</a> ，这里放出来的是机芯部分，大多数朋友应该够用了。</p><p><img src="https://blog.joyer.top/2022-10-25/KT69L5W6QGMMH$X9OEHCGJE.png"></p><p><img src="https://blog.joyer.top/2022-10-25/-2157c4ebf5655450.jpg"></p><h2 id="开拆！"><a href="#开拆！" class="headerlink" title="开拆！"></a>开拆！</h2><p>从上一家卖家手里拿到了两个关于爱华 T30 的零件机吭哧吭哧就开拆，上家其实保养得不错，除了飞线有点难看问题不大。</p><p><img src="https://blog.joyer.top/2022-10-25/IMG20220930203345.jpg"></p><p>拆得七零八落后我终于看到了机芯，给大家看看实际的机芯</p><p><img src="https://blog.joyer.top/2022-10-25/IMG20221001212232.jpg"></p><p>一套更换完毕上油，机芯顺滑了不少，颤音也收敛不少，虽然还是十分明显的，不过也只能这样了，这是能找到最好状态的替换件，以后有机会可能还会再淘淘再更换，大写爱华不能落寞！</p><p><img src="https://blog.joyer.top/2022-10-25/IMG20221022191135.jpg"></p><p>放上视频给大家感受一下打理前与打理后的区别（其实我感觉没啥区别,可能好了一丢丢）。</p><div style="position:relative; padding-bottom:75%; width:100%; height:0">    <iframe src="//player.bilibili.com/player.html?bvid=BV1dP411J7vs&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position:absolute; height: 100%; width: 100%;"></iframe></div><div style="position:relative; padding-bottom:75%; width:100%; height:0">    <iframe src="//player.bilibili.com/player.html?bvid=BV1bR4y1d7X6&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position:absolute; height: 100%; width: 100%;"></iframe></div><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这篇 blog 或许还会再更新，敬请期待大写爱华的传奇。</p>]]></content>
      
      
      <categories>
          
          <category> 数码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数码产品 </tag>
            
            <tag> 怀旧 </tag>
            
            <tag> 磁带机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题 442. 数组中重复的数据</title>
      <link href="/2022-05-08/"/>
      <url>/2022-05-08/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>今天是一道值得用来讲的题目，来看题 <a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/">LeetCode 442. 数组中重复的数据</a> 。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，其中 <code>nums</code> 的所有整数都在范围 <code>[1, n]</code> 内，且每个整数出现 <strong>一次</strong> 或 <strong>两次</strong> 。请你找出所有出现 两次 的整数，并以数组形式返回。</p><p>你必须设计并实现一个时间复杂度为 <strong>O(n)</strong> 且仅使用常量额外空间的算法解决此问题。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,3,2,7,8,2,3,1]</span><br><span class="line">输出：[2,3]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>注：题目来源于 <a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/">LeetCode 442. 数组中重复的数据</a> </p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这道题如果不加额外条件其实很简单，但是它加了额外条件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">必须设计并实现一个时间复杂度为 O(n) 且仅使用常量额外空间的算法解决此问题</span><br></pre></td></tr></table></figure><p><code>常量额外空间</code>即O(1)，代表着我们除了用来输出输入的空间只能再加入空间固定的变量。而<code>时间复杂度O(n)</code>则是要求我们只能有一层循环。<br>那么在时间和空间都那么紧张的条件下我们能做什么呢？我们可以注意到题目中的两个条件：</p><ul><li><code>nums</code> 的所有整数都在范围 <code>[1, n]</code> 内</li><li>整数数组 <code>nums</code> 长度为 <code>n</code> </li></ul><p>对于一个数组来说，它能包含的信息除了数组中的元素还有什么呢？对了，就是每个元素的下标。因为题目中nums的长度为 <code>n</code> 而 <code>nums</code> 的元素范围在 <code>[1, n]</code>，我们大可通过修改 <strong>下标为val</strong> 的元素的值来标志 <strong>值为val</strong> 的元素是否出现过而不影响我们使用 <code>nums</code> 里面的所有元素。</p><p>重申一遍， <strong><code>nums</code> 的元素范围在 <code>[1, n]</code> 中</strong> 。我们可以通过 <code>num[val-1]*=-1</code> 令其成为负数标志 <code>val</code> 这个数已经在 <code>nums</code> 中出现过一次了，而我们如果需要使用 <code>num[val-1]</code> 则只需要使用其绝对值 <code>abs(num[val-1])</code> 即可。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时：40 ms, 在所有 C++ 提交中击败了84.35%的用户</span></span><br><span class="line"><span class="comment">//内存消耗：32.7 MB, 在所有 C++ 提交中击败了66.33%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> num=<span class="built_in">abs</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(nums[num<span class="number">-1</span>]&gt;<span class="number">0</span>)</span><br><span class="line">                nums[num<span class="number">-1</span>]*=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans.<span class="built_in">push_back</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><p>此解法非唯一解，且不一定是最好的解法，如果您有更好的解法，欢迎在评论区中提出。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
          <category> 学习日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国内部分社区 APP 上线 IP 属地之后的一些思考</title>
      <link href="/2022-05-02/"/>
      <url>/2022-05-02/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>就在最近国内许多社交 APP 相继上线了在个人账号边显示 IP 属地的一个小功能，并且是强制的，刚上线就遭到老百姓们的议论，有人说这样会出现隐私问题，但有人也非常看好。  </p><p><img src="https://blog.joyer.top/2022-05-02/2.jpg"></p><p>对于这个功能我倒是比较看好的，网络舆论是一个很恐怖的东西，如果被某些不安好心的个人或者组织对网络社交进行渗透，很有可能能够控制整个网络社交的风向，这对网络安全甚至上升到国家安全都是一件非常严肃的事情。</p><p>靠着这个功能很快就能够发现平日里一些出言不逊的“大拳师”、“精日”、“精美”突然没了踪迹，很是解气。</p><p>比较好玩的是在这个功能上线之后，社交APP里的好多靠着分享“国外”生活赢取流量的大V直接被揭穿，说是在国外的但事实上 IP 属地却在国内，很是让人好笑（当然不能排除为了能访问国内网站而搭上回国梯子的一些用户，这种情况是存在的）（图源网络如侵删）。</p><p><img src="https://blog.joyer.top/2022-05-02/1.jpeg"></p><p>虽然这个功能很容易被破解，破解的方法我就不说了，大家都懂，但是这个功能的上线是非常好的一个开始，能够有效扫除网络中的一部分垃圾信息与不实信息。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
          <category> 瞎叭叭 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现路由器检测网络状态并重新登录</title>
      <link href="/2022-05-01/"/>
      <url>/2022-05-01/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>书接上回，自发布文章 <a href="https://blog.joyer.top/2021-12-03-3/">无锡学院校园网 实现路由器自动登录上网 支持多设备连接</a> 之后使用这个脚本已经过了差不多大半年了，依然很好用。<br>但最近经常发现路由器会无故掉线，思考可能是校园网的动态 IP 的持有时间被缩短然后强制下线，或者也有可能是系统问题，遂再写脚本实现<code>检测网络连接状态并重新登录</code>。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>其实实现这个脚本也是非常简单，这里直接给出代码,复制粘贴即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">timeout=5</span><br><span class="line">url=www.baidu.com</span><br><span class="line">if [ $(curl -I -s --connect-timeout $&#123;timeout&#125; $&#123;url&#125; -w %&#123;http_code&#125; | tail -n1) = &quot;200&quot; ]</span><br><span class="line">then</span><br><span class="line">echo &quot;network is online&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;network not connect&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">执行登录脚本</span></span><br><span class="line">sh /etc/storage/bjxy_auto_log.sh</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>原理是使用 curl 命令的 <code>-w %&#123;http_code&#125;</code> 参数读取网站的 http 状态码，如果是 200 则证明网络通畅，后上传路由器设定计划任务即可，这里不再赘述，有需要可阅 <a href="https://blog.joyer.top/2021-12-03-3/">无锡学院校园网 实现路由器自动登录上网 支持多设备连接</a> 中上传路由器的部分。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>天文</title>
      <link href="/photo-tianwen/"/>
      <url>/photo-tianwen/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="2020年8月30日摄"><a href="#2020年8月30日摄" class="headerlink" title="2020年8月30日摄"></a>2020年8月30日摄</h1><div class="fj-gallery"><p><img src="http://blog.joyer.top/photo-tianwen/1.jpeg"><br><img src="http://blog.joyer.top/photo-tianwen/2.jpeg">  </p>          </div>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
          <category> 天文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 照片 </tag>
            
            <tag> 天文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>风光</title>
      <link href="/photo-fengguang/"/>
      <url>/photo-fengguang/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="2022年9月25日摄"><a href="#2022年9月25日摄" class="headerlink" title="2022年9月25日摄"></a>2022年9月25日摄</h1><div class="fj-gallery"><p><img src="http://blog.joyer.top/photo-fengguang/20220925-_DSC4671.jpg"><br><img src="http://blog.joyer.top/photo-fengguang/20220925-_DSC4691.jpg"><br><img src="http://blog.joyer.top/photo-fengguang/20220925-_DSC4749.jpg"></p>          </div><h1 id="2021年10月3日摄"><a href="#2021年10月3日摄" class="headerlink" title="2021年10月3日摄"></a>2021年10月3日摄</h1><div class="fj-gallery"><p><img src="http://blog.joyer.top/photo-fengguang/6.jpeg"><br><img src="http://blog.joyer.top/photo-fengguang/5.jpeg"></p>          </div><h1 id="2021年8月19日摄"><a href="#2021年8月19日摄" class="headerlink" title="2021年8月19日摄"></a>2021年8月19日摄</h1><div class="fj-gallery"><p><img src="http://blog.joyer.top/photo-fengguang/1.jpeg"><br><img src="http://blog.joyer.top/photo-fengguang/2.jpeg"><br><img src="http://blog.joyer.top/photo-fengguang/3.jpeg"><br><img src="http://blog.joyer.top/photo-fengguang/4.jpeg"></p>          </div><h1 id="2020年7月8日摄"><a href="#2020年7月8日摄" class="headerlink" title="2020年7月8日摄"></a>2020年7月8日摄</h1><div class="fj-gallery"><p><img src="http://blog.joyer.top/photo-fengguang/7.jpeg"><br><img src="http://blog.joyer.top/photo-fengguang/8.jpeg"></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
          <category> 风光 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 风光 </tag>
            
            <tag> 照片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人文</title>
      <link href="/photo-renwen/"/>
      <url>/photo-renwen/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="2022年9月25日摄"><a href="#2022年9月25日摄" class="headerlink" title="2022年9月25日摄"></a>2022年9月25日摄</h1><div class="fj-gallery"><p><img src="http://blog.joyer.top/photo-renwen/20220925-_DSC4567.jpg"><br><img src="http://blog.joyer.top/photo-renwen/20220925-_DSC4580.jpg"><br><img src="http://blog.joyer.top/photo-renwen/20220925-_DSC4681.jpg">  </p>          </div><h1 id="2022年2月11日摄"><a href="#2022年2月11日摄" class="headerlink" title="2022年2月11日摄"></a>2022年2月11日摄</h1><div class="fj-gallery"><p><img src="http://blog.joyer.top/photo-renwen/1.jpeg"><br><img src="http://blog.joyer.top/photo-renwen/2.jpg"><br><img src="http://blog.joyer.top/photo-renwen/3.jpg">  </p>          </div><h1 id="2021年10月3日摄"><a href="#2021年10月3日摄" class="headerlink" title="2021年10月3日摄"></a>2021年10月3日摄</h1><div class="fj-gallery"><p><img src="http://blog.joyer.top/photo-renwen/4.jpeg"><br><img src="http://blog.joyer.top/photo-renwen/5.jpeg"><br><img src="http://blog.joyer.top/photo-renwen/6.jpeg"></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
          <category> 人文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 照片 </tag>
            
            <tag> 人文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题 357. 统计各位数字都不同的数字个数</title>
      <link href="/2022-04-11/"/>
      <url>/2022-04-11/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>残念，博主对于 dp 真的非常地深恶痛绝，实在是学不会 dp 其中的精髓，dp 苦手 😩，所以今天的每日一题放弃吧。</p><p><img src="https://blog.joyer.top/2022-04-11/1.jpg"></p><p>开玩笑，明明是每日一题欸！ <a href="https://leetcode-cn.com/problems/count-numbers-with-unique-digits/">LeetCode 357. 统计各位数字都不同的数字个数</a> 。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个整数 n ，统计并返回各位数字都不同的数字 x 的个数，其中 0 &lt;= x &lt; 10^n 。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：91</span><br><span class="line">解释：答案应为除去 11、22、33、44、55、66、77、88、99 外，在 0 ≤ x &lt; 100 范围内的所有数字。 </span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>刚看完：好欸又是暴力完活的一天！…… 但是这个难度绝对不会是暴力能够解决的！</p><p>仔细思索可以发现，当 <code>n=2</code> 时，我们易得出重复数字是 11、22、33、44……88、99 这几个，那么当 <code>n=3</code> 时呢？会发现这里面包含了 9 个 <code>n=2</code> 的重复数字 x11、x22……x99 ，当然也有诸如 100、101、202…… 这样的数字当然也是。</p><p>所以这样子有叠加性质的答案绝对是动态规划无疑了！（动规真乃天杀我也！！！）</p><p>所以我们应该开始往动规的方向去思考这道题的转移方程了，但是我不会写x（绝望） 。</p><p><img src="https://blog.joyer.top/2022-04-11/1.jpg"></p><p>所以直接一点好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i]= dp[i<span class="number">-1</span>] + ( dp[i<span class="number">-1</span>] - dp[i<span class="number">-2</span>] ) * (<span class="number">10</span> - i - <span class="number">1</span> );</span><br></pre></td></tr></table></figure><ul><li><p><code>dp [ i-1 ]</code> 应该是不用解释的；  </p></li><li><p><code>(10 - i - 1 )</code> 可以举个栗子：</p><blockquote><p>n=2 时，符合题意的数字共有 91个，剩余的 <del>被选中的孩子</del> 其实是在 n=1 的数字中刚好选择了能让它成为重复数字的非重复数字，像 1 选择了 1 成为了 11，但如果它选择的是除 1 以外的 其他 9 个数字就不会叛变了。  </p></blockquote><blockquote><p>n=3 时情况也是一样的，叛变的 n=2 中的某些数字在成为三位数时恰好选择了能让它成为重复数字的数字，像是 13 找了个 1 成为了 113，这样的数字如果选择的是 1 和 3 之外的 8 个数字就不会叛变了。</p></blockquote><p>有没有发现？叛变了的数字是其中占比的 i-1/10 ，而没叛变的数字是其中占比的 <code>1-(i-1/10)</code> 也就是 <code>( dp[i-1] - dp[i-2] ) * (10 - i - 1 )</code> 了。</p></li><li><p><code>( dp[i-1] - dp[i-2] )</code> 其实是为了避免重复计算。在上面的例子中，因为 位数为 1 的数 在 <code>n=2</code> 时就已经被计算了，我们只需要关心 位数为 2 的数就可以了。</p></li></ul><p>题解就是这么多了，写代码吧！</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用时0ms 超越 100% 消耗 5.9MB 超越34.29%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+(dp[i<span class="number">-1</span>]-dp[i<span class="number">-2</span>])*(<span class="number">10</span>-(i<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><p>dp真的是一个很恐怖的东西ORZ。</p><p>此解法非唯一解，且不一定是最好的解法，如果您有更好的解法，欢迎在评论区中提出。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
          <category> 学习日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 思维 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题 653. 两数之和 IV - 输入 BST</title>
      <link href="/2022-03-21/"/>
      <url>/2022-03-21/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>今天是一道简单题，来看题目<a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/">LeetCode 653. 两数之和 IV - 输入 BST</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个二叉搜索树 root 和一个目标结果 k，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例1：<br><img src="https://assets.leetcode.com/uploads/2020/09/21/sum_tree_1.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [5,3,6,2,4,null,7], k = 9</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>示例2：<br><img src="https://assets.leetcode.com/uploads/2020/09/21/sum_tree_2.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [5,3,6,2,4,null,7], k = 28</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>题目很简单，一看就懂。</p><p>先简单介绍一下BST，BST是满足以下三个条件的二叉树：</p><ol><li><p>节点的左子树包含的节点的值小于该节点的值</p></li><li><p>节点的右子树包含的节点的值大于等于该节点的值</p></li><li><p>节点的左子树和右子树都是BST  </p><p><img src="https://assets.leetcode.com/uploads/2020/09/21/sum_tree_1.jpg"><br>接下来介绍两种解法。</p></li></ol><h2 id="BST特性：中序遍历-双指针"><a href="#BST特性：中序遍历-双指针" class="headerlink" title="BST特性：中序遍历 + 双指针"></a>BST特性：中序遍历 + 双指针</h2><p>因为是BST，所以直接使用中序遍历能够转换成有序数组，进而能够使用双指针。</p><p>先把整个二叉树通过中序遍历加入到数组 <code>nums</code> 中，然后对其用双指针 <code>nums[l] + nums[r]</code> 计算出值与 <code>k</code> 对比大小:</p><ul><li>如果 <code>nums[l] + nums[r] &gt; k</code> 则 <code>r--</code>  </li><li>如果 <code>nums[l] + nums[r] &lt; k</code> 则 <code>l++</code></li><li>如果 <code>nums[l] + nums[r] == k</code> 则 <code>return true</code></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行 32 ms 超越 81.55%  消耗 35.9 MB 超越 75.94%</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">BSTout</span>(root);</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">while</span>(l!=r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[l]+nums[r]&gt;k)</span><br><span class="line">                r--;</span><br><span class="line">            <span class="keyword">if</span>(nums[l]+nums[r]&lt;k)</span><br><span class="line">                l++;</span><br><span class="line">            <span class="keyword">if</span>(l!=r&amp;&amp;nums[l]+nums[r]==k)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BSTout</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">BSTout</span>(root-&gt;left);</span><br><span class="line">        nums.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">BSTout</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="暴力：二叉树遍历-hash-判断"><a href="#暴力：二叉树遍历-hash-判断" class="headerlink" title="暴力：二叉树遍历 + hash 判断"></a>暴力：二叉树遍历 + hash 判断</h2><p>直接对二叉树遍历，然后将其加入set中,如果发现 <code>set.find(k - val)!=map.end()</code> 成立,则直接 <code>return ture</code>,反之遍历完二叉树后 <code>return false</code>，十分简单粗暴。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行 36 ms 超越 67.15%  消耗 37.8 MB 超越 36.32%</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">find</span>(k-root-&gt;val)!=nums.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        nums.<span class="built_in">insert</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findTarget</span>(root-&gt;left,k) || <span class="built_in">findTarget</span>(root-&gt;right,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="PS"><a href="#PS" class="headerlink" title="PS:"></a>PS:</h1><p>轻松愉快地完成了本次每日一题。  </p><p>国际惯例：<br>此解法非唯一解，且不一定是最好的解法，如果您有更好的解法，欢迎在评论区中提出。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
          <category> 学习日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 递归 </tag>
            
            <tag> BST </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经历了一点小挫折以后，我突然开始理解了抽烟喝酒</title>
      <link href="/2022-03-20-2/"/>
      <url>/2022-03-20-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>今天做题的时候脑子简直就搅成了一团浆糊，看着题头晕脑涨，突然心中冒出来个想法，“抽支烟冷静一下吧”，让我打了打冷颤。</p><p>虽然我平时偶尔会自己为自己来杯酒陶醉一番，但我并不抽烟。因为自小以来长辈的教育，以及本身也深知吸烟有害，所以我根本就不碰烟，平时拒绝掉朋友的烟，还会被白眼称为“小朋友”。</p><p>不理解为什么烟民们会非常习惯性的下意识抽一支烟，在以前就我看来其实仅仅是烟瘾。 但今天我对此发生了改观，原因就是我突然也想抽一支（。为了赶快将这个奇怪的念头压下去，我拿出了咖啡，却发现居然只剩下一包了……快速地烧了壶开水，打开包装给自己滤了杯咖啡，一口入嘴，豆子那股草本味就在我口腔中爆发出来，让我清醒不少……突然发现，手中的咖啡就如同烟民们手中那根烟一样，我豁然开朗，解开了“下意识地抽一支烟”这个疑惑。它根本就不是能够解释得出来的一件事，就是这样般、本该这样般地自然而然的事。<br><img src="https://blog.joyer.top/2022-03-20-2/1.jpg"><br>或许我也真的需要一根烟来帮助我思考问题，在一筹莫展的时候，抽一支烟换换心情，或许能够走出死胡同找到答案。</p><p>但我依旧不会去因此而抽烟，哈哈哈。</p><p>但我要去买咖啡了，下一篇文章见。 <img src="https://bu.dusays.com/2021/01/15/1c131772d1bb2.png" alt="滑稽"></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
          <category> 瞎叭叭 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
            <tag> 瞎叭叭 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题 2039. 网络空闲的时刻</title>
      <link href="/2022-03-20-1/"/>
      <url>/2022-03-20-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>今天的题目是<a href="https://leetcode-cn.com/problems/the-time-when-the-network-becomes-idle/">LeetCode 2039. 网络空闲的时刻</a> ，令我产生多个思考，来看题目。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个有 n 个服务器的计算机网络，服务器编号为 <code>0</code> 到 <code>n - 1</code> 。同时给你一个二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ui, vi]</code> 表示服务器 <code>ui</code> 和 <code>vi</code> 之间有一条信息线路，在 <strong>一秒</strong> 内它们之间可以传输 <strong>任意</strong> 数目的信息。再给你一个长度为 <code>n</code> 且下标从 <strong>0</strong> 开始的整数数组 <code>patience</code> 。</p><p>题目保证所有服务器都是 <strong>相通</strong> 的，也就是说一个信息从任意服务器出发，都可以通过这些信息线路直接或间接地到达任何其他服务器。</p><p>编号为 <code>0</code> 的服务器是 <strong>主</strong> 服务器，其他服务器为 <strong>数据</strong> 服务器。每个数据服务器都要向主服务器发送信息，并等待回复。信息在服务器之间按 <strong>最优线路</strong> 传输，也就是说每个信息都会以 <strong>最少时间</strong> 到达主服务器。主服务器会处理 <strong>所有</strong> 新到达的信息并 <strong>立即</strong> 按照每条信息来时的路线 <strong>反方向</strong> 发送回复信息。</p><p>在 <strong>0</strong> 秒的开始，所有数据服务器都会发送各自需要处理的信息。从第 <strong>1</strong> 秒开始，每 一秒最 <strong>开始</strong> 时，每个数据服务器都会检查它是否收到了主服务器的回复信息（包括新发出信息的回复信息）：</p><ul><li>如果还没收到任何回复信息，那么该服务器会周期性 重发 信息。数据服务器 <code>i</code> 每 <code>patience[i]</code> 秒都会重发一条信息，也就是说，数据服务器 i 在上一次发送信息给主服务器后的 <code>patience[i]</code> 秒 后 会重发一条信息给主服务器。</li><li>否则，该数据服务器 <strong>不会重发</strong> 信息。</li></ul><p>当没有任何信息在线路上传输或者到达某服务器时，该计算机网络变为 <strong>空闲</strong> 状态。</p><p>请返回计算机网络变为 <strong>空闲</strong> 状态的 <strong>最早秒数</strong> 。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例1：<br><img src="https://assets.leetcode.com/uploads/2021/09/22/quiet-place-example1.png" alt="来自LeetCode"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">输入：edges = [[0,1],[1,2]], patience = [0,2,1]</span><br><span class="line">输出：8</span><br><span class="line">解释：</span><br><span class="line">0 秒最开始时，</span><br><span class="line">- 数据服务器 1 给主服务器发出信息（用 1A 表示）。</span><br><span class="line">- 数据服务器 2 给主服务器发出信息（用 2A 表示）。</span><br><span class="line"></span><br><span class="line">1 秒时，</span><br><span class="line">- 信息 1A 到达主服务器，主服务器立刻处理信息 1A 并发出 1A 的回复信息。</span><br><span class="line">- 数据服务器 1 还没收到任何回复。距离上次发出信息过去了 1 秒（1 &lt; patience[1] = 2），所以不会重发信息。</span><br><span class="line">- 数据服务器 2 还没收到任何回复。距离上次发出信息过去了 1 秒（1 == patience[2] = 1），所以它重发一条信息（用 2B 表示）。</span><br><span class="line"></span><br><span class="line">2 秒时，</span><br><span class="line">- 回复信息 1A 到达服务器 1 ，服务器 1 不会再重发信息。</span><br><span class="line">- 信息 2A 到达主服务器，主服务器立刻处理信息 2A 并发出 2A 的回复信息。</span><br><span class="line">- 服务器 2 重发一条信息（用 2C 表示）。</span><br><span class="line">...</span><br><span class="line">4 秒时，</span><br><span class="line">- 回复信息 2A 到达服务器 2 ，服务器 2 不会再重发信息。</span><br><span class="line">...</span><br><span class="line">7 秒时，回复信息 2D 到达服务器 2 。</span><br><span class="line"></span><br><span class="line">从第 8 秒开始，不再有任何信息在服务器之间传输，也不再有信息到达服务器。</span><br><span class="line">所以第 8 秒是网络变空闲的最早时刻。</span><br></pre></td></tr></table></figure><p>示例2：<br><img src="https://assets.leetcode.com/uploads/2021/09/04/network_a_quiet_place_2.png" alt="leetCode"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：edges = [[0,1],[0,2],[1,2]], patience = [0,10,10]</span><br><span class="line">输出：3</span><br><span class="line">解释：数据服务器 1 和 2 第 2 秒初收到回复信息。</span><br><span class="line">从第 3 秒开始，网络变空闲。</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>今天的题目那是十分之长，看吐了，谢谢你 LeetCode。</p><p>看完后第一反应就是广搜（BFS），从主服务器 0 开始向四周搜索所有子服务器的 <strong>最短路径</strong> 。</p><blockquote><p>如果不理解广搜可以先看看我以前的BFS相关文章 <a href="https://blog.joyer.top/2021-12-07-1/">LeetCode每日一题 1034. 边界着色</a></p></blockquote><p>获得最短路径之后我们开始计算每一个服务器从 <strong>第一次</strong> 发信到 <strong>最后一次</strong> 收到回信之间的时间，在这些服务器中耗时最长的即是本题答案：“计算机网络变为 <strong>空闲</strong> 状态的 <strong>最早秒数</strong> ” 。</p><p>我们已知 服务器 <code>n</code> 的重复发信周期为 <code>patience[n]</code> 秒，以及通过上文提到的搜索计算出来的服务器 <code>n</code> 到服务器 <code>n</code> 的最短通信时间 <code>server_time</code> 秒。</p><p>这里会分为两种情况：</p><ul><li><code>patience[n] &gt;= server_time</code>：当服务器 <code>n</code> 收到它第一次发信的回信后，重复发信周期还未到；或是因为收信优先级高于发信，还没来得及发信就收到了第一次的发信，打断了下一次的发信，这个时候就已经完成了这个服务器的整个收发动作，网络中也不再存在来自此服务器的数据或是发送给此服务器的数据，则一次收发动作 <code>server_time*2 + 1</code> 就是 服务器 <code>n</code> 的整个 “变为空闲状态的最早秒数”。</li><li><code>patience[n] &lt; server_time</code>：当服务器 <code>n</code> 还未收到它第一次发信的回信时就已触发了重复发信周期，这个时候在它收到第一次发信的回信后，整个网络中还存在着 <code>(time * 2-1) /patience[n]</code> 个关于这个服务器 <code>n</code> 的 数据，此时这个服务器还将继续收信不能变为空闲状态，所以当达到服务器 <code>n</code> 的整个 “变为空闲状态的最早秒数” 应该是 <code>server_time*2 + patience[n]*((time * 2-1) /patience[n]) + 1</code>。</li></ul><p>然而当 <code>patience[n] &gt;= server_time</code> 时 <code>patience[n]*((time * 2-1) /patience[n])==0</code>, 所以以上两个条件的公式可以复用为 <code>server_time*2 + patience[n]*((time * 2-1) /patience[n]) + 1</code>。</p><p>由于本人思路不及他人，所以以上题解思路来自于 <a href="https://leetcode-cn.com/problems/the-time-when-the-network-becomes-idle/solution/wang-luo-kong-xian-de-shi-ke-by-leetcode-qttv/">LeetCode 官方题解</a> ，如果您有兴趣看一看我的思路请翻到 <a href="https://blog.joyer.top/2022-03-20-1/#PS">我的思路</a>。</p><p>开始写代码吧。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行 680 ms 超越 9.48%  消耗 198.4 MB 超越 26.72%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">networkBecomesIdle</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="keyword">int</span>&gt;&amp; patience)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">visit</span><span class="params">(patience.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">edges_map</span>(patience.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:edges)</span><br><span class="line">        &#123;</span><br><span class="line">            edges_map[i[<span class="number">0</span>]].<span class="built_in">push_back</span>(i[<span class="number">1</span>]);</span><br><span class="line">            edges_map[i[<span class="number">1</span>]].<span class="built_in">push_back</span>(i[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        visit[<span class="number">0</span>]=<span class="literal">true</span>; <span class="comment">//主服务器去除</span></span><br><span class="line">        <span class="keyword">int</span> max_time=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> time=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> qsize=que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;qsize;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i:edges_map[que.<span class="built_in">front</span>()])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!visit[i])</span><br><span class="line">                    &#123;</span><br><span class="line">                        que.<span class="built_in">emplace</span>(i);</span><br><span class="line">                        max_time=<span class="built_in">max</span>(time*<span class="number">2</span> + patience[i]*((time*<span class="number">2</span><span class="number">-1</span>) / patience[i]),max_time);</span><br><span class="line">                        visit[i]=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            time++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_time+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>理解官方思路后重新写了代码，但都无法追上官方的成绩，思考了一下午的时间，还是放弃……如果有大佬路过看到此篇能提供帮助小辈万分感谢。<br><img src="https://blog.joyer.top/2022-03-20-1/1.png"><br>实际上我的思路与官方的大差不差，但在实现方法上有不同。<br>来看整个代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;<span class="keyword">int</span>,set&lt;<span class="keyword">int</span>&gt;&gt; edges_map;  <span class="comment">//使用map与set会浪费空间，所以尽量使用vector</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; server_lenght;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">networkBecomesIdle</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="keyword">int</span>&gt;&amp; patience)</span> </span>&#123;</span><br><span class="line">        server_lenght.<span class="built_in">resize</span>(patience.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:edges)</span><br><span class="line">        &#123;</span><br><span class="line">            edges_map[i[<span class="number">0</span>]].<span class="built_in">insert</span>(i[<span class="number">1</span>]);</span><br><span class="line">            edges_map[i[<span class="number">1</span>]].<span class="built_in">insert</span>(i[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max_time=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">find_server</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;server_lenght.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(server_lenght[i]*<span class="number">2</span> % patience[i] == <span class="number">0</span>)</span><br><span class="line">                max_time = <span class="built_in">max</span>(server_lenght[i]*<span class="number">4</span> - patience[i],max_time);</span><br><span class="line">                <span class="comment">//从第0秒开始发信，到第 server_lenght[i]*2 秒收到回信时，此服务器最后一条信息已开始 server_lenght[i]*2 % patience[i] 秒</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(server_lenght[i]*<span class="number">2</span> &gt; patience[i])</span><br><span class="line">                max_time = <span class="built_in">max</span>(server_lenght[i]*<span class="number">4</span> - (server_lenght[i]*<span class="number">2</span> % patience[i]),max_time);</span><br><span class="line">                <span class="comment">//当出现 server_lenght[i]*2 % patience[i] == 0 条件时服务器的第一次发信已收到回信，则还在第 0 秒的最后一条发信停止发信</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                max_time = <span class="built_in">max</span>(server_lenght[i]*<span class="number">2</span>,max_time);</span><br><span class="line">                <span class="comment">//如果 patience[i] &gt; server_lenght[i]*2 , 此时服务器还尚未发信</span></span><br><span class="line">            cout&lt;&lt;server_lenght[i]&lt;&lt;endl;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> max_time+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find_server</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> sl)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:edges_map[n])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(server_lenght[i]&lt;=sl+<span class="number">1</span> &amp;&amp; server_lenght[i]!=<span class="number">0</span>) <span class="comment">//防止回环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(server_lenght[i]==<span class="number">0</span> || server_lenght[i]&gt;sl+<span class="number">1</span>)</span><br><span class="line">                server_lenght[i]=sl+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">find_server</span>(i,sl+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我对于此题的理解是：</p><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>对于这个BFS，我使用的是递归的方式先求出所有的数据服务器到主服务器的最短路径，再遍历计算变为休眠的时间。这样会造成偏离一整个数组的时间浪费，如果整合到一块会节省平均 500ms 的时间。</p><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>沿用上面提到的几个已知量 <code>server_time</code> 与 <code>patience[n]</code>，讨论一下 <code>patience[n] &lt; server_time</code> 这个情况。  </p><blockquote><p>当服务器<code>n</code>的首次发信收到回复时，距离服务器 <code>n</code> 最后一次发信的时间已过 <code>server_time*2%patience[n]</code> 秒，则此时这个信号将在 <code>server_time*2 - server_time*2%patience[n]</code> 秒后被服务器 <code>n</code> 收信。</p></blockquote><p>思路其实是没有问题的，但麻烦在这个公式本身有问题 —— 它不能像官方题解中的公式一样融合为一个公式，所以需要条件判断。</p><ul><li>当 <code>patience[n] &lt; server_time</code> 时……</li><li>当 <code>server_time % patience[n] = 0</code> 时……</li><li>当 <code>patience[n] &gt; server_time</code> 时……</li></ul><p>三个条件语句足以让本来有已经有了三个循环嵌套的程序代码执行时间平均增加 500 ms，所以这个思路事实上是不建议的。</p><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>由此题引发的反思。</p><p>以目前的情况来看，我虽然已经能够独立解决一些题目，但仍然欠缺不少地方。</p><p>对于算法来说，不仅仅是个人将算法记下来就可以了，而是需要将其转化运用到实际开发中。在算法的练习中需要时刻注意灵活运用，避免死板套公式，并且还需要注意在有限的时间空间内得到解决方案，不能滥用空间时间。</p><p>最后国际惯例：</p><p>此解法非唯一解，且不一定是最好的解法，如果您有更好的解法，欢迎在评论区中提出。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
          <category> 学习日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 广度搜索 </tag>
            
            <tag> BFS </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题 606. 根据二叉树创建字符串</title>
      <link href="/2022-03-19-1/"/>
      <url>/2022-03-19-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>早上好各位，今天起的很早就打开了LeetCode，让我们开始吧。</p><p><a href="https://leetcode-cn.com/problems/construct-string-from-binary-tree/">LeetCode 606. 根据二叉树创建字符串</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。</p><p>空节点则用一对空括号 “()” 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: 二叉树: [1,2,3,4]</span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     3</span><br><span class="line">   /    </span><br><span class="line">  4     </span><br><span class="line"></span><br><span class="line">输出: &quot;1(2(4))(3)&quot;</span><br><span class="line"></span><br><span class="line">解释: 原本将是“1(2(4)())(3())”，</span><br><span class="line">在你省略所有不必要的空括号对之后，</span><br><span class="line">它将是“1(2(4))(3)”。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: 二叉树: [1,2,3,null,4]</span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     3</span><br><span class="line">     \  </span><br><span class="line">      4 </span><br><span class="line"></span><br><span class="line">输出: &quot;1(2()(4))(3)&quot;</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>题目做多了后，一看就是递归。</p><p>我们把要输出的 <code>string</code> 提取出来写出公式：<br><code>root-&gt;val(root-&gt;left)(root-&gt;right)</code></p><p>一目了然。</p><p>再将递归方法套进去</p><p><code>root-&gt;val(tree2str(root-&gt;left))(tree2str(root-&gt;right))</code></p><p>当然还有其他条件了。</p><ul><li>当 <code>root-&gt;right == nullptr</code> 时我们要省略掉 <code>root-&gt;right</code> 的括号,如下：<br><code>root-&gt;val(tree2str(root-&gt;left))</code></li><li>当 <code>root-&gt;right==nullptr &amp;&amp; root-&gt;left==nullptr</code> 时我们就只需要返回 <code>root-&gt;val</code> </li><li>当 <code>root == nullptr</code> 时我们只需要返回空字符串 “”</li></ul><p>这样我们才算真正地完成了对题目的解读，可以开始写代码了。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行 12 ms 超越 90.28%  消耗 25.5 MB 超越 49.86%</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">tree2str</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right==<span class="literal">nullptr</span> &amp;&amp; root-&gt;left==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">to_string</span>(root-&gt;val)+<span class="string">&quot;(&quot;</span>+<span class="built_in">tree2str</span>(root-&gt;left)+<span class="string">&quot;)&quot;</span>+<span class="string">&quot;(&quot;</span>+<span class="built_in">tree2str</span>(root-&gt;right)+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">to_string</span>(root-&gt;val)+<span class="string">&quot;(&quot;</span>+<span class="built_in">tree2str</span>(root-&gt;left)+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>简单！</p><h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><p>此解法非唯一解，且不一定是最好的解法，如果您有更好的解法，欢迎在评论区中提出。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
          <category> 学习日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode加练 6. Z 字形变换</title>
      <link href="/2022-03-18-2/"/>
      <url>/2022-03-18-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>不知道用什么顶部图了，直接套用每日一题的好了。<br>今天加练的原因是前一道题实在不咋地，思来想去再做一题罢，<a href="https://leetcode-cn.com/problems/zigzag-conversion/">LeetCode 6. Z 字形变换</a> 。<br>来看题目。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure><p>##示例<br>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><br><span class="line">输出：&quot;PAHNAPLSIIGYIR&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class="line">输出：&quot;PINALSIGYAHRPI&quot;</span><br><span class="line">解释：</span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;A&quot;, numRows = 1</span><br><span class="line">输出：&quot;A&quot;</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>模拟！是模拟！我突然发现我已经做了两三天模拟了x。其实关于这道题我们只需要找到其中的规律即可，我们来看看这个所谓的 “z字形排列”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@   @   @       0     8           16</span><br><span class="line">@  @@  @@       1   7 9        15 17</span><br><span class="line">@ @ @ @ @       2  6  10    14    18</span><br><span class="line">@@  @@  @       3 5   11 13       19</span><br><span class="line">@   @   @       4     12          20</span><br></pre></td></tr></table></figure><p>就是这样的排列，然后我们需要按行来输出，用下标来表示：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 8 16 1 7 9 15 17 2 6 10 14 18 3 5 11 13 19 4 12 20</span><br></pre></td></tr></table></figure><p>看出什么情况了吗？<br>让我们再简化一下这该死的阵列。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@ @ @     0   8     16</span><br><span class="line">@@@@@     1 7 9  15 17</span><br><span class="line">@@@@@     2 6 10 14 18</span><br><span class="line">@@@@@     3 5 11 13 19</span><br><span class="line">@ @ @     4   12    20</span><br></pre></td></tr></table></figure><p>和前面是一样的，这次呢？<br>看出来了吧。<br>第一行的情况：<br><code>8 - 0 = 8</code> <code>16 - 8 = 8</code><br>和它们同列的情况：<br><code>9 - 1 = 8</code> <code>10 - 2 = 8</code><br><code>11 - 3 = 8</code> <code>20 - 12 = 8</code><br>他们都在长列。</p><p>那短列的情况呢？<br><code>15 - 7 = 8</code> <code>14 - 6 = 8</code><br>它们也相差 8 。</p><p>我们得出结论，它们隔一列的下标都差 8 。</p><p>换个 numRows = 3 看看？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@ @ @       0   4   8</span><br><span class="line">@@@@@       1 3 5 7 9</span><br><span class="line">@ @ @       2   6   10</span><br></pre></td></tr></table></figure><p>情况好像不太一样了，这次隔列相差 4 ，怎么会这样？这个隔列相差 x 个单位肯定与 numberRows 有关系。  </p><p>稍微计算一下可以发现 <code>x = 2 ( numberRows - 1 )</code>,您看看是不是这样？</p><p>直接清晰明了了有没有！</p><p>虽然我们的第0，2，4，……列能够计算了，但是1，3，5，……怎么办呢？我们只要知道第 1 列的元素下标就能算出剩下的了。</p><p>再观察一下可以发现是 ``x = 2(numberRows-n-1)’’ （这里的 n 是第 n 行），我们发现变量以后计算公式就方便多了。</p><p>可以开始写代码了。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numRows==<span class="number">1</span> || numRows&gt;s.<span class="built_in">size</span>()) <span class="comment">//当出现这两种情况时只需要输出原 s</span></span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">        string ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>,k1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ans.<span class="built_in">size</span>()&lt;s.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=s[k];</span><br><span class="line">            k+=<span class="number">2</span>*(numRows<span class="number">-1</span>);  <span class="comment">//指向长列的下一个下标</span></span><br><span class="line">            <span class="keyword">if</span>(n&lt;numRows<span class="number">-1</span> &amp;&amp; n&gt;<span class="number">0</span> &amp;&amp;k1&lt;s.<span class="built_in">size</span>())<span class="comment">//当 n&lt;1 且 n&gt;numRows 时有短列参与</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans+=s[k1]; </span><br><span class="line">                k1+=<span class="number">2</span>*(numRows<span class="number">-1</span>); <span class="comment">//指向短列的下一个下标</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;=s.<span class="built_in">size</span>()) <span class="comment">//当每行的下标都超出了s.size() 我们就知道该轮到下一行了</span></span><br><span class="line">            &#123;</span><br><span class="line">                n++,k=n,k1=n+<span class="number">2</span>*(numRows-n<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><p>简单吧！我想了一下午！（</p><p>我发现这个题目有非常多的公式可以计算出下标结果，所以会有很多种解法，我这个只是其中一种解法，有不同见解欢迎下方讨论！</p><p>刷题惯例：</p><p>此解法非唯一解，且不一定是最好的解法，如果您有更好的解法，欢迎在评论区中提出。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
          <category> 学习日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题 2043. 简易银行系统</title>
      <link href="/2022-03-18-1/"/>
      <url>/2022-03-18-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p> <a href="https://leetcode-cn.com/problems/simple-bank-system/">LeetCode 2043. 简易银行系统</a> 虽说是一道普通题，但事实上其实是简单题，LeetCode 似乎特别喜欢把一些设计类题目写成普通题。<br>不是很想讲，但是踩了小坑，为了让我自己记住还是写一下吧。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>你的任务是为一个很受欢迎的银行设计一款程序，以自动化执行所有传入的交易（转账，存款和取款）。银行共有 <code>n</code> 个账户，编号从 <code>1</code> 到 <code>n</code> 。每个账号的初始余额存储在一个下标从 0 开始的整数数组 <code>balance</code>中，其中第 <code>(i + 1)</code> 个账户的初始余额是 <code>balance[i]</code> 。</p><p>请你执行所有 有效的 交易。如果满足下面全部条件，则交易 有效 ：</p><ul><li>指定的账户数量在 1 和 n 之间</li><li>取款或者转账需要的钱的总数 小于或者等于 账户余额。</li></ul><p>实现 Bank 类：</p><ul><li><code>Bank(long[] balance)</code> 使用下标从 <code>0</code> 开始的整数数组 <code>balance</code> 初始化该对象。</li><li><code>boolean transfer(int account1, int account2, long money)</code> 从编号为 <code>account1</code> 的账户向编号为 <code>account2</code> 的账户转帐 <code>money</code> 美元。如果交易成功，返回 <code>true</code> ，否则，返回 <code>false</code> 。</li><li><code>boolean deposit(int account, long money)</code> 向编号为 <code>account</code> 的账户存款 <code>money</code> 美元。如果交易成功，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li><li><code>boolean withdraw(int account, long money)</code> 从编号为 <code>account</code> 的账户取款 <code>money</code> 美元。如果交易成功，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;Bank&quot;, &quot;withdraw&quot;, &quot;transfer&quot;, &quot;deposit&quot;, &quot;transfer&quot;, &quot;withdraw&quot;]</span><br><span class="line">[[[10, 100, 20, 50, 30]], [3, 10], [5, 1, 20], [5, 20], [3, 4, 15], [10, 50]]</span><br><span class="line">输出：</span><br><span class="line">[null, true, true, true, false, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">Bank bank = new Bank([10, 100, 20, 50, 30]);</span><br><span class="line">bank.withdraw(3, 10);    // 返回 true ，账户 3 的余额是 $20 ，所以可以取款 $10 。</span><br><span class="line">                         // 账户 3 余额为 $20 - $10 = $10 。</span><br><span class="line">bank.transfer(5, 1, 20); // 返回 true ，账户 5 的余额是 $30 ，所以可以转账 $20 。</span><br><span class="line">                         // 账户 5 的余额为 $30 - $20 = $10 ，账户 1 的余额为 $10 + $20 = $30 。</span><br><span class="line">bank.deposit(5, 20);     // 返回 true ，可以向账户 5 存款 $20 。</span><br><span class="line">                         // 账户 5 的余额为 $10 + $20 = $30 。</span><br><span class="line">bank.transfer(3, 4, 15); // 返回 false ，账户 3 的当前余额是 $10 。</span><br><span class="line">                         // 所以无法转账 $15 。</span><br><span class="line">bank.withdraw(10, 50);   // 返回 false ，交易无效，因为账户 10 并不存在。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这道题就是从头到尾把各种操作操作模拟一次就可以了，主要要注意以下几点：</p><ul><li>账户必须存在于 <code>balance</code> 数组中，也就是说如果这个 account 超出 <code>balance</code> 的 size 就不存在这个账户，所有的操作方法都需要检查一次是否存在。</li><li><code>withdraw()</code> 中需要注意 money 不能够大于 balance[account-1] 。</li><li>在题目中没有讲清楚关于 <code>transfer()</code> 这个方法的具体运作。应该来说是不允许 account1 和 account2 相同的，这样等于说是自己给自己转钱了；但题目答案允许了这种操作，导致我的提交错了两次，哭笑不得了属于是。</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行 212 ms 超越 65.13% 消耗 114.1 MB 超越 41.21%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> &#123;</span></span><br><span class="line">    vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; balance_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bank</span>(vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&amp; balance) &#123;</span><br><span class="line">        balance_=balance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> account1, <span class="keyword">int</span> account2, <span class="keyword">long</span> <span class="keyword">long</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(account1==account2) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(balance_[account1<span class="number">-1</span>]&gt;=money) <span class="comment">//用两个判断来省略脱裤子放屁的步骤，实际提交中可以节省 50ms</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">withdraw</span>(account1,money))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">deposit</span>(account2,money))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                balance_[account1<span class="number">-1</span>]+=money;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> account, <span class="keyword">long</span> <span class="keyword">long</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(account<span class="number">-1</span>&gt;balance_.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        balance_[account<span class="number">-1</span>]+=money;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> account, <span class="keyword">long</span> <span class="keyword">long</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(account<span class="number">-1</span>&gt;balance_.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(balance_[account<span class="number">-1</span>]&lt;money)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        balance_[account<span class="number">-1</span>]-=money;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><p>请各位写代码的时候切记仔细检查代码错漏，我就是因为忘记在本题中 account 忘记减 1 导致提交错误了两次，在实际开发中出现这样的问题将可能会引发非常严重的错误，要以此引以为戒。</p><p>另外是真的很想吐槽 LeetCode 这样的题目，弄出这样脱裤子放屁的东西。</p><p>另外应该还可以缩减程序的执行时长，如果有会的大佬希望能够指点迷津。</p><p>最后是日常惯例：</p><p>此解法非唯一解，且不一定是最好的解法，如果您有更好的解法，欢迎在评论区中提出。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
          <category> 学习日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题LeetCode 720. 词典中最长的单词</title>
      <link href="/2022-03-17-2/"/>
      <url>/2022-03-17-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>今天的每日一题！<a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/">LeetCode 720. 词典中最长的单词</a>,想了很久，功夫还是不到家啊。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给出一个字符串数组 words 组成的一本英语词典。返回 words 中最长的一个单词，该单词是由 words 词典中其他单词逐步添加一个字母组成。</p><p>若其中有多个可行的答案，则返回答案中字典序最小的单词。若无答案，则返回空字符串。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;w&quot;,&quot;wo&quot;,&quot;wor&quot;,&quot;worl&quot;, &quot;world&quot;]</span><br><span class="line">输出：&quot;world&quot;</span><br><span class="line">解释： 单词&quot;world&quot;可由&quot;w&quot;, &quot;wo&quot;, &quot;wor&quot;, 和 &quot;worl&quot;逐步添加一个字母组成。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;a&quot;, &quot;banana&quot;, &quot;app&quot;, &quot;appl&quot;, &quot;ap&quot;, &quot;apply&quot;, &quot;apple&quot;]</span><br><span class="line">输出：&quot;apple&quot;</span><br><span class="line">解释：&quot;apply&quot; 和 &quot;apple&quot; 都能由词典中的单词组成。但是 &quot;apple&quot; 的字典序小于 &quot;apply&quot; </span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>很简单一个东西，结果给我想复杂了。<br>阅读题目，作为一个<code>words</code>中最长的一个字符串，它由<code>words</code>中其他单词逐步添加一个字母形成，那么这个字符串 word 的 <code>word.substr(0,word.size()-1))</code> 必定存在。</p><p>以示例一为例，<code>“world”.substr(0,&quot;world&quot;.size()-1) = &quot;worl&quot;</code>, 而 <code>“worl”.substr(0,&quot;worl&quot;.size()-1) = &quot;wor&quot;</code>,很好理解，我们就是要找这种类型的最长的字符串，所以我们只要检索这个字符串的<code>substr(0,word.size()-1))</code>是否存在于words中即可，如果这个字符串的所有“前导”全都存在，就记录进ans中。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="我写的代码"><a href="#我写的代码" class="headerlink" title="我写的代码"></a>我写的代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行 1260ms 超越5.26%   内存 25.2 MB 超越 45.15%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">longestWord</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),[](<span class="keyword">const</span> string &amp; a,<span class="keyword">const</span> string &amp; b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a.<span class="built_in">size</span>()!=b.<span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">return</span> a.<span class="built_in">size</span>()&gt;b.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">return</span> a&gt;b;</span><br><span class="line">        &#125;); <span class="comment">//从大到小排序，字典序靠前的向后移</span></span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:words)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> bl=<span class="literal">true</span>;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(ans.<span class="built_in">size</span>()&gt;i.<span class="built_in">size</span>()) <span class="comment">//当ans长度超过当前遍历到的字符串的长度后直接退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i.<span class="built_in">size</span>()<span class="number">-1</span>;j&gt;<span class="number">0</span>;j--) <span class="comment">//蠢蛋写法，每一个字符串都要再次从头开始遍历查询，消耗大量时间</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">find</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),i.<span class="built_in">substr</span>(<span class="number">0</span>,j))==words.<span class="built_in">end</span>()) </span><br><span class="line">                &#123;</span><br><span class="line">                    bl=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(bl)</span><br><span class="line">                ans=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>写完后其实不满意，耗时太高，于是看了官方的代码。笨蛋如我，居然没想到用 set 容器，按照官方做法可以节省下一大笔的时间花费和空间花费。</p><h2 id="官方做法"><a href="#官方做法" class="headerlink" title="官方做法"></a>官方做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestWord</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [](<span class="keyword">const</span> string &amp; a, <span class="keyword">const</span> string &amp; b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.<span class="built_in">size</span>() != b.<span class="built_in">size</span>()) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> a &gt; b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);  <span class="comment">//从小到大排序，字典序靠前的向后移</span></span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        set&lt;string&gt; cnt;</span><br><span class="line">        cnt.<span class="built_in">emplace</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> word : words) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt.<span class="built_in">count</span>(word.<span class="built_in">substr</span>(<span class="number">0</span>, word.<span class="built_in">size</span>() - <span class="number">1</span>))) &#123; <span class="comment">//当查到“前导”字符串即添加进set容器并保存进ans</span></span><br><span class="line">                cnt.<span class="built_in">emplace</span>(word);</span><br><span class="line">                ans = word;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><ul><li><p>简单题大翻车，重新认识到我自身到底有多菜，还要多多加油！</p></li><li><p>此解法非唯一解，且不一定是最好的解法，如果您有更好的解法，欢迎在评论区中提出。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
          <category> 学习日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MikuMikuDance 制作初体验，毫不掩饰地说，我看得性奋了</title>
      <link href="/2022-03-17-1/"/>
      <url>/2022-03-17-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>百般无聊刷着B站之际，一瞬之间突然想做个MMD玩玩，正巧以前有过一点点经验，说完就直接开干，以下是成果。</p><h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1><div style="position:relative; padding-bottom:75%; width:100%; height:0">    <iframe src="//player.bilibili.com/player.html?bvid=BV1Gb4y1p7Dg&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position:absolute; height: 100%; width: 100%;"></iframe></div><h1 id="关于MMD"><a href="#关于MMD" class="headerlink" title="关于MMD"></a>关于MMD</h1><p>MMD真的很好玩。从本人的体验来说，MMD 是我们这帮二刺螈爱好者表达对某个作品或是单个角色的喜爱然后创作出二创的最好的表达方式之一，不仅观看这些二创作品的观众能得到非常好的观感，对于二创作者自身都是一件成就感满满的事。</p><p>我直到昨天真正开始浅尝 MMD 的时候才发现 MMD 这个圈子是真的比我预想的规模还要庞大，有各种各样的社群网站资源网站来维护 MMD 这个庞大的圈子，并且也有属于这个圈子中人们不谋而合的规则来保护他们的圈子，在这个圈子里的每个人的愿望都如此纯粹（有点当年年轻的陈叔叔与他的 BiliBili 的感觉），就是为了自己喜欢的作品和角色去做这样的工作，他们制作的模型分镜特效甚至能够被免费分享，当然了不能用于商用，规则类似于我们这帮臭写代码的其中的代码开源规则。</p><p><img src="https://blog.joyer.top/2022-03-17-1/1.png" alt="发现新世界 BowlRoll"></p><p>我不禁感叹啊这东西太好了，让我仿佛回到了少年时期的那个夏天，空气都如此纯净。</p><p>稍微有点扯远了，做 MMD 当然不是一件简单的事，除了最基础的模型，你还得懂美术，得懂动作k帧，得懂场景渲染（就是那些shader之类的玩意），得会写分镜设计镜头语言，还得会视频制作……这么一套下来就一个人或者是几个人干真的超乎想象，但是关键人家又做得这么好！属实是为爱发电。</p><h1 id="做了一个-MMD！（拖更LeetCode的理由！）"><a href="#做了一个-MMD！（拖更LeetCode的理由！）" class="headerlink" title="做了一个 MMD！（拖更LeetCode的理由！）"></a>做了一个 MMD！<del>（拖更LeetCode的理由！）</del></h1><p>当然我也就是个门外汉，就只会套套大佬的模型、动作和镜头，自己做的话那是必然不可能，稍微学过一点皮毛的人都知道这玩意属实废精力。2000帧K个动作花费的时间真的很离谱。</p><p><img src="https://blog.joyer.top/2022-03-17-1/2.png" alt="MikuNikuDance 软件截图"><br>毫不掩饰地说，制作过程中我是真的看得<del>一度弟弟充血</del>，大佬做的表情和动作属实撩人，在此之前我认为我已经正式踏入现充门槛了，然而当我对此起反应之后，我不禁惊呼 “md我这不还是纯纯二刺螈嘛”，以及产生 “要和纸片人结婚” 的错觉，而后感叹 “啊纸片人真好啊，人生不就如此嘛”（。</p><p>很离谱，时过境迁我依旧还是那个热爱二刺螈的少年。</p><p>真就很离谱。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
          <category> 瞎叭叭 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
            <tag> MikuMikuDance </tag>
            
            <tag> 初音未来 </tag>
            
            <tag> 视频 </tag>
            
            <tag> 模型 </tag>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题 599. 两个列表的最小索引总和</title>
      <link href="/2022-03-14-1/"/>
      <url>/2022-03-14-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>LeetCode刷题坚持每一天！今天是摸鱼的一天！题目<a href="https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/">LeetCode 599. 两个列表的最小索引总和</a>.</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>假设 Andy 和 Doris 想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。</p><p>你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设答案总是存在。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: list1 = [&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;]，list2 = [&quot;Piatti&quot;, &quot;The Grill at Torrey Pines&quot;, &quot;Hungry Hunter Steakhouse&quot;, &quot;Shogun&quot;]</span><br><span class="line">输出: [&quot;Shogun&quot;]</span><br><span class="line">解释: 他们唯一共同喜爱的餐厅是“Shogun”。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入:list1 = [&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;]，list2 = [&quot;KFC&quot;, &quot;Shogun&quot;, &quot;Burger King&quot;]</span><br><span class="line">输出: [&quot;Shogun&quot;]</span><br><span class="line">解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这个题目让我纠结了很久，主要是“最少的索引和”这个字眼让我十分疑惑，翻了翻评论区得到解释 —— 两列表的下标和（看来还是我自己的理解能力不够哇/_ \），那么这样就说得通可以开始解题了。</p><p>整个题目意思其实就是让我们在最小下标和的情况下输出两个列表中同样的元素项目，也就是说我们既然能够输出下标和为 1 的答案，就不要输出下标和为 2 的答案，尽管下标和为 2 的元素比下标和为 1 的元素多。</p><p>那么我们就针对<code>list1</code>建立一个哈希表，每个元素内容作为 first，对应的 second 为<code>list1</code>中这个元素的下标； 而后我们可以开始循环遍历<code>list2</code>，当<code>list2</code>中的元素内容在哈希表中能找到，那么就计算<code>list1</code>此元素的下标与此元素在<code>list2</code>中对应的下标的和，然后对比 <code>vector&lt;string&gt; ans</code> 中的元素所指向的下标和，如果当前元素的下标和小于<code>ans</code>中元素的下标和，那么就直接清空ans并添加当前元素，但如果两元素的下标相等，那么就将其直接添加进数组<code>ans</code>中。</p><p>只需要这样，我们就能确定ans中的元素一定是我们需要的那些个。</p><p>那么开始写代码吧！</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行 100ms 超越23%   内存 35.8 MB 超越 78%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRestaurant</span><span class="params">(vector&lt;string&gt;&amp; list1, vector&lt;string&gt;&amp; list2)</span> </span>&#123;</span><br><span class="line">        map&lt;string,<span class="keyword">int</span>&gt; list1_;<span class="comment">//哈希表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list1.<span class="built_in">size</span>();i++)<span class="comment">//遍历输入哈希表</span></span><br><span class="line">            list1_[list1[i]]=i;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list2.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(list1_.<span class="built_in">find</span>(list2[i])!=list1_.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                list1_[list2[i]]+=i;  <span class="comment">//计算下标和</span></span><br><span class="line">                <span class="keyword">if</span>(ans.<span class="built_in">size</span>()==<span class="number">0</span>)  <span class="comment">//当ans中没有元素时直接添加</span></span><br><span class="line">                    ans.<span class="built_in">push_back</span>(list2[i]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(list1_[ans[<span class="number">0</span>]]&gt;list1_[list2[i]])  <span class="comment">//当ans中的元素在map中的下标和大于list2[i]时则清空替换</span></span><br><span class="line">                    ans.<span class="built_in">clear</span>(),ans.<span class="built_in">push_back</span>(list2[i]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(list1_[ans[<span class="number">0</span>]]==list1_[list2[i]]) <span class="comment">//当ans中的元素在map中的下标和等于list2[i]时则添加进ans</span></span><br><span class="line">                    ans.<span class="built_in">push_back</span>(list2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><p>此解法非唯一解，且不一定是最好的解法，如果您有更好的解法，欢迎在评论区中提出。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
          <category> 学习日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题 393. UTF-8 编码验证</title>
      <link href="/2022-03-13-2/"/>
      <url>/2022-03-13-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>久违的LeetCode每日一题又回来啦！，这一次是简单题！虽然表面上是普通题！来看题目！<a href="https://leetcode-cn.com/problems/utf-8-validation/">LeetCode 393. UTF-8 编码验证</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个表示数据的整数数组<code>data</code>，返回它是否为有效的 UTF-8 编码。</p><p>UTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则：</p><ol><li>对于 <code>1 字节</code> 的字符，字节的第一位设为 0 ，后面 7 位为这个符号的 unicode 码。</li><li>对于 <code>n 字节</code> 的字符 (n &gt; 1)，第一个字节的前 n 位都设为1，第 n+1 位设为 0 ，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。</li><li>这是 <code>UTF-8</code> 编码的工作方式：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Char. number range  |        UTF-8 octet sequence</span><br><span class="line">   (hexadecimal)    |              (binary)</span><br><span class="line">--------------------+---------------------------------------------</span><br><span class="line">0000 0000-0000 007F | 0xxxxxxx</span><br><span class="line">0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure></li></ol><p>注意：输入是整数数组。只有每个整数的 最低 8 个有效位 用来存储数据。这意味着每个整数只表示 1 字节的数据。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：data = [197,130,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：数据表示字节序列:11000101 10000010 00000001。</span><br><span class="line">这是有效的 utf-8 编码，为一个 2 字节字符，跟着一个 1 字节字符。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：data = [235,140,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：数据表示 8 位的序列: 11101011 10001100 00000100.</span><br><span class="line">前 3 位都是 1 ，第 4 位为 0 表示它是一个 3 字节字符。</span><br><span class="line">下一个字节是开头为 10 的延续字节，这是正确的。</span><br><span class="line">但第二个延续字节不以 10 开头，所以是不符合规则的。</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>先来读懂题目！<code>data</code> 中的每一个整数元素都代表着一个字节，题目要求我们判别用整数数组 <code>data</code> 来表示的一段编码流是否符合 UTF-8 编码标准， 先来说明 UTF-8 编码标准。</p><ol><li>作为一个 <code>1 字节</code> 字符的编码，前 1 位不能为 1 ，例如 <code>0100 0000</code> 、 <code>0100 1111</code>.</li><li>作为一个 <code>n 字节</code> 字符的编码，第一个字节的编码的前 n 位必须为 1 ，且第 n+1 位必须为 0 ，而后 n-1 个字节的编码必须是 10 开头， 例如  <code>1110 0000</code>  <code>1000 0000</code>  <code>1011 0000</code></li><li>UTF-8 编码最多只存在 4 字节字符。</li></ol><p>乍一看，我去怎么要搞二进制，心里就开始盘算起D转B那些个不想回忆的东西；不过当真正看懂题目后，其实是非常简单的，只要数组<code>data</code>没有以下提到的几个条件，那么它就是合规范的 UTF-8 编码。</p><ol><li>存在与前后字节无关系的前两位为 10 的字节，例如 <code>1100 1000</code> <code>1000 1000</code> <code>1000 0000</code>（前两个字节的编码为一个 <code>2 字节</code> 编码）。</li><li>存在作为一个 <code>n 字节</code> 编码的第二、三、四字节中一个字节及以上非 10 开头，例如 <code>1110 0000</code> <code>1000 0000</code> <code>1110 0000</code> 或 <code>1110 0000</code> <code>0000 0000</code> <code>1000 0000</code> 。</li><li>存在作为一个 <code>n 字节</code> 编码却缺失字节，例如 <code>1100 0000</code> (data.size()==1)。</li><li>存在从前往后数有超过五位数为1的单个字节，例如 <code>1111 1000</code> 。</li></ol><p>如果逃过了以上条件的<code>data</code>，那么它就一定是一串符合UTF-8编码的编码流。</p><p>在验证以上四点时，我们没必要一定将单个十进制整数元素转换成二进制再进行验证，那样计算太慢了，我们不妨反过来将几个二进制阈值手算转换为十进制进行验证。</p><p>如<code>1111 0000</code>转换成十进制是 240，或 <code>1000 0000</code>转换为十进制是 128，瞬间就变简单了有木有！ψ(｀∇´)ψ</p><p>于是让我们开始敲代码吧！</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2022/03/13 执行 8ms 超越 97.92%，内存 13.5MB 超越 88.43%</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validUtf8</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;data.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> count_=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(data[i]&gt;<span class="number">247</span>) <span class="comment">//字节超出4位即非法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(data[i]&lt;<span class="number">128</span>) <span class="comment">//1字节跳过</span></span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(data[i]&lt;<span class="number">192</span>) <span class="comment">//一字节前两位10即违法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(data[i]&gt;=<span class="number">240</span>) <span class="comment">//大于1111 0000 count++</span></span><br><span class="line">                count_++;</span><br><span class="line">            <span class="keyword">if</span>(data[i]&gt;=<span class="number">224</span>) <span class="comment">//大于1110 0000 count++</span></span><br><span class="line">                count_++;</span><br><span class="line">            <span class="keyword">if</span>(data[i]&gt;=<span class="number">192</span>) <span class="comment">//大于1100 0000 count++</span></span><br><span class="line">                count_++;</span><br><span class="line">            <span class="keyword">if</span>(count_+i&gt;data.<span class="built_in">size</span>()) <span class="comment">//字节超出数组范围即非法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;count_;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( data[i+j]&lt;<span class="number">128</span> || data[i+j]&gt;=<span class="number">192</span> )  <span class="comment">//在二三四字节前两位非10即非法</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i+=count_;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><p>此解法非唯一解，且不一定是最好的解法，如果您有更好的解法，欢迎在评论区中提出。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
          <category> 学习日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摸鱼 弄了一个FF14相关的网页导航</title>
      <link href="/2022-03-13-1/"/>
      <url>/2022-03-13-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>昨天突发奇想想做一个ff14相关的导航，于是闲的蛋疼做了一个这样没卵用的网页导航。不过其实要说更实用的导航当然还是 <a href="https://www.ffxiv.cn/v2/">素素攻略站</a> 。</p><p><img src="https://joyerliii.github.io/2022-03-13-1/1.png"></p><p>权当是做了一个小练习吧x，我已经很久没有碰过 html 了。想要访问看一看的朋友可以从顶部导航栏直接进入（虽然内容一定会让人简陋到失望x）。</p><p>如果有朋友喜欢这样的导航当然就更好了，有什么建议或者意见可以在下方提出，有什么想加入的功能我会积极加入。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 网页 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最终幻想14 </tag>
            
            <tag> 游戏 </tag>
            
            <tag> HTML </tag>
            
            <tag> 网页导航 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国服 最终幻想14 6.0 晓月的终焉 开服倒计时！</title>
      <link href="/2022-02-17-1/"/>
      <url>/2022-02-17-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div id="timer" style="font-family:arial;color:#ffd400;font-size:50px;font-weight:600;text-align:center;white-space: pre-line;"></div><script type="text/javascript" language="javascript">var endDate=new Date(2022,2,16,10,00,00);(function daoJiShi(){var now=new Date();var oft=Math.round((endDate-now)/1000);var ofd=parseInt(oft/3600/24);var ofh=parseInt((oft%(3600*24))/3600);var ofm=parseInt((oft%3600)/60);var ofs=oft%60;document.getElementById('timer').innerHTML='距离 国服 FF14 6.0 晓月的终焉 \n 开服还剩下' +' \n ' +ofd+ ' 天 '+ ofh + '小时' + ofm +'分' + ofs + '秒';if(ofd<1 && ofh>=10){document.getElementById('timer').innerHTML='距离 国服 FF14 6.0 晓月的终焉 \n 开服还剩下' +' \n ' +ofd+ ' 天 '+ ofh + '小时' + ofm +'分' + ofs + '秒'+'\n官方正在维护服务器进行更新！';}if(ofs<0){document.getElementById('timer').innerHTML='FF14 6.0 晓月的终焉 开服啦！';return;};oft=null;ofd=null;ofh=null;ofm=null;ofs=null;setInterval(daoJiShi,1000);//setTimeout('daoJiShi()',1000);}());</script>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
          <category> 最终幻想14 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FF14 </tag>
            
            <tag> 最终幻想14 </tag>
            
            <tag> 游戏 </tag>
            
            <tag> 晓月的终焉 </tag>
            
            <tag> FF14 6.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Hexo使用valine无法连接国际版leancloud的问题</title>
      <link href="/2022-02-06-1/"/>
      <url>/2022-02-06-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本站使用的评论引擎是 valine ，但是 leancloud 国内版无法直接使用评论管理系统以及无法直接唤醒部署，其原因是国内版 leancloud 这样的操作要使用备案过的链接绑定才能使用，遂我将数据库搬迁到了 leancloud 国际版。</p><p>但是搬迁到国际版是无法直接使用的，翻阅 <a href="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js">valine的js文件</a> 后发现其默认是使用国内版 leancloud 的链接尝试访问数据的。</p><p>翻阅后发现其实只需要在配置文件里的valine一栏中添加一个名为<code>serverURLs</code>的参数即可解决。</p><p>参数的内容是<code>REST API</code>服务地址，在 leancloud 国际版的设置中可以找到，是这样的一个样式：<a href="https://xxxxxxx.api.lncldglobal.com./">https://xxxxxxx.api.lncldglobal.com。</a></p><p>添加后执行 <code>hexo clean</code> 清除后执行 <code>hexo g -d</code> 上传即可。</p><p>由此一来即可使用 leancloud 国际版作为 valine 的数据库了。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 博客 </tag>
            
            <tag> valine </tag>
            
            <tag> leancloud </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桂林-柳州8天自驾游攻略</title>
      <link href="/2022-1-28-1/"/>
      <url>/2022-1-28-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>元月份考完试回到桂林后就开始风风火火地开始自驾游旅行了，这趟旅行是在学校的时候考试之前就已经决定好了。</p><h2 id="关于车"><a href="#关于车" class="headerlink" title="关于车"></a>关于车</h2><p>在桂林租了一辆车，原本说好是租科鲁兹的，结果到了那里站点说没有科鲁兹了，两辆都出了事故，给我换了一辆宝沃BX5，说实话心情不是很愉悦，虽然是15年的高配板。这家伙不仅油耗高，8天下来1100公里的旅程居然烧去了8.9个油，很心痛；不仅如此，在我的八天旅程中屡次出现车机卡死的情况，每次卡死都需要完全断电至少一个小时后才能重启再用，网上查了一下，似乎是宝沃车机的通病。有时候为了赶路真的没有时间顾虑车机的情况，只能唔着头皮开，要知道车机包括全景影像都全部gg了，停车的时候，只能是唔着头皮倒……</p><p>这一趟下来宝沃BX5的体验那是真的糟糕透了，以后如果要租车，或是买车，我是绝对不会考虑宝沃！如果有朋友想买宝沃……还是算了吧。<br><img src="https://joyerliii.github.io/2022-1-22-1/2.png"></p><h2 id="关于费用"><a href="#关于费用" class="headerlink" title="关于费用"></a>关于费用</h2><p>其实最贵的花费是油费，其次到猫儿山的门票+酒店，要价直逼500元，吃吃喝喝一趟下来总共花费该有小六七千了。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>那么以下内容就到正文部分了，我会从我这八天的行程以及游玩的顺序开始介绍游玩的地点，游玩的项目主要是自然风光类，游乐园啥的没有在内，标题超链接是高德地图中其具体位置，其中包括我对每个游玩地点的推荐程度，为五分制，可能比较主观，大家客观看待。</p><h2 id="柳州-游览地点"><a href="#柳州-游览地点" class="headerlink" title="柳州-游览地点"></a>柳州-游览地点</h2><h3 id="马鞍山公园"><a href="#马鞍山公园" class="headerlink" title="马鞍山公园"></a><a href="https://surl.amap.com/25dvPeKIdfQ">马鞍山公园</a></h3><strong> 推荐程度：⭐⭐⭐⭐<br>体验：⭐⭐⭐✨<br>门票：免费<br>游玩时长：2小时<br></strong><p>马鞍山是柳州市区内最高山峰之一，有人可能要说“怎么不说鱼峰山啊”，鱼峰山哪里够马鞍山高啊……由于马鞍山的地理位置原因，这里是唯一能够看见柳江大拐弯的地方，并且全市风光尽收眼底(图源 <a href="https://blog.caion.work/">CaIon</a> )。</p><p><img src="http://r.photo.store.qq.com/psc?/V11jnnGZ4QJdXl/ETWql2gUF22pNmiMBc.OAa036P*kOosjVuPjBdg.IIszUB3QMABPQebIHL7GUTPpx.Lw*bjOCdCwUmLKQwty5ZJtFHYrTATR9MohA8SuI4I!/r"></p><p>虽说马鞍山确实是柳州城区最高山峰之一，但其实爬山的过程并不漫长；要注意的是过程中会有三段楼梯比较陡，真的很陡！但其长度也不算太长，而且也有扶手可扶，不必过于担心。如果实在受不了还可以搭乘电梯上山，上山20元下山10元，但是要注意这台电梯的运行时间只在白天，并且下午结束营业的时间特别早。</p><p>山上没有特别的游玩项目,唯一的缆车也被拆了。仅仅是为了看到柳州全城以及柳江大拐弯，<del>还有健身（划掉）</del>。能看到柳州全城以及柳江大拐弯的地方是一个玻璃观景台，拍照建议带广角镜头哦，如果有超广角那更好了。我们去的那天下了点小雨，上山后雾蒙蒙的啥也没看清😂，所以请大家如果要上山要看清楚本天的天气哦。</p><p><img src="https://joyerliii.github.io/2022-1-28-1/2.jpg"></p><p>我的建议是如果你当日目的仅为马鞍山公园的话就不要驱车前往，马鞍山公园的停车位根本不够用，并且前往其路程中单行线还有诡异的单行线，如果要驱车前往只能再往前200米停进一个酒店的停车场里，但是那个位置开进去容易出来难，停车场路口刚好在红绿灯面前，遇上晚高峰堵车很难受，再加上附近还有学校，更堵（亲身经历,下图便是在酒店停车场杆外的惨状，纹丝不动，残念……）。</p><p><img src="https://joyerliii.github.io/2022-1-28-1/13.jpg"></p><p>马鞍山公园周围有很多其他公园，都是免费的，如果时间充足还能去鱼峰公园和龙潭公园，也是不错的去处。</p><h3 id="凤凰岭大桥"><a href="#凤凰岭大桥" class="headerlink" title="凤凰岭大桥"></a><a href="https://surl.amap.com/26FKdtsS7hB">凤凰岭大桥</a></h3><strong> 推荐程度：⭐⭐⭐✨<br>体验：⭐⭐⭐✨<br>门票：免费<br>游玩时长：1小时<br></strong><p>凤凰岭大桥在柳州城区内，是目前世界上最大的风雨桥<del>（除了中国南方哪里还能找到风雨桥啊）</del>。白天的时候并不出彩，倒是晚上确实很漂亮,可以前往打卡拍照。附近停车场很多，大桥西向底部有停车场，导航不标，是一个很好的停车位置。当然了如果驾车往桥上开也是很好的体验。</p><p><img src="https://joyerliii.github.io/2022-1-28-1/3.jpg"></p><h3 id="柳州版可可托海"><a href="#柳州版可可托海" class="headerlink" title="柳州版可可托海"></a><a href="https://surl.amap.com/27mIBYWtfl5">柳州版可可托海</a></h3><strong> 推荐程度：⭐⭐<br>体验：⭐⭐✨<br>门票：免费<br>游玩时长：1小时<br></strong><p>柳州版可可托海，位置在市区外，驱车前往40多公里，有一段陡峭的上坡泥路，建议SUV或直接上皮卡越野（但是又有宝骏E200这种车进得去还能拍照返图，令人实在摸不着头脑）。</p><p>这个地方是在小红书找到的，懂了吧。 其实就是柳州境内一废弃矿山，土质成分比较出众，表现出来是显红色的土壤。如果拍人像还是可以的，能作为不错的背景，但是风景……就算了吧。</p><p>开车体验很赞，视野开阔、场地空旷并且车尾伴随着沙石飞溅，几度我都差点以为我正在跑拉力然后想着前面的弯道手刹一拉来个漂移，但车里的电子手刹给我又几度瞬间拉回现实😂。</p><p>小红书里头描述了里面有个小湖很漂亮，结果我在开车沿着路搜寻的时候不小心进到森林里，心想着既然有路就一定有位置，结果发现的时候已经处在山坡上并且整个车倾斜了45°，还好是四驱suv的宝沃BX5，<del>不然车子可能已经滚下山了吧</del>。然后成功下了山找了另一条路出到了大路上。确实这件事要感谢站点那边给我换的是宝沃……但是宝沃不行是确实的🤣。</p><p><img src="https://joyerliii.github.io/2022-1-28-1/4.jpg"></p><p>如果是专程前往绝对不值当，但如果顺路的话还是能去打个卡的。</p><h3 id="凤山水库"><a href="#凤山水库" class="headerlink" title="凤山水库"></a><a href="https://surl.amap.com/22whIen0Aj">凤山水库</a></h3><strong> 推荐程度：⭐⭐⭐<br>体验：⭐⭐⭐✨<br>门票：免费<br>游玩时长：1小时<br></strong><p>凤山水库也在柳州城区外，驱车前往50多公里，末尾有15公里左右是乡道，停车瞎停就行，但是能停的位置比较少，两辆车极限了。</p><p>凤山水库的水似乎已经干了，现在成为了一处草场，有农家在里头养鸡和羊，建议去的话不要打扰到他们的生活。也是在小红书找到的，怎么说呢，比柳州版可可托海好了不少，小红书推荐的景点要自己擦亮眼睛才可以发现好去处。</p><p>凤山水库里头的一大特点便是草场，因为水库里很开阔，好玩的是草场如此像是草原，但周围典型的喀斯特山峰又不可能在草原中出现，这样子的交接碰撞就使得景观非常地魔幻，老实说我甚至不太敢相信能在多山的广西中找到这样的草场，又特别是柳州这样的工业城市。</p><p><img src="https://joyerliii.github.io/2022-1-28-1/6.jpg"></p><p>我们去的时候算是冬季，所以草场看上去比较暗淡<del>（这时候的照片就需要魔法帮助，上图的草是调过色调的）</del>。里面十分开阔，拍照建议超广角,人像也能作为很不错的背景。没有见过草原的朋友可以去体验体验,但是和柳州版可可托海一样，如果你是专程前往，不建议，顺路打个卡还是可以的。</p><hr><h2 id="桂林-游览地点"><a href="#桂林-游览地点" class="headerlink" title="桂林-游览地点"></a>桂林-游览地点</h2><h3 id="猫儿山"><a href="#猫儿山" class="headerlink" title="猫儿山"></a><a href="https://surl.amap.com/55u4u61x09d">猫儿山</a></h3><strong> 推荐程度：⭐⭐⭐⭐⭐<br>体验：⭐⭐⭐⭐✨<br>门票：105起步，住宿289起步<br>游玩时长：1天12小时<br></strong><p>猫儿山可谓是全篇最佳。猫儿山在桂林城区以外，全程100公里，直到湖南邵阳边界，虽然有些远，但一定是值得一去的地方。路途会经过比较坑洼的县道，并且有一个长度2千米的隧道，尾段是30公里的山路，山路不用担心，虽然路不宽，但是是铺好沥青的，体验良好。</p><p>猫儿山是华南第一高山，单凭这一点就十分有吸引人前往打卡的魄力。猫儿山的景色是绝对的无与伦比以及从未有过的体验，我无法用壮丽或者是辽阔这样普通的形容词去形容它，也不能说宏伟之类，那样不对，猫儿山的景色不是那种令人严肃的感受……总而言之，就是那种在你一览众山小的时候，无法言语的那种兴奋感以及嘴里只能说出“卧槽”之类的脏话失禁了，一直在那转来转去嘴巴却不自觉不带控制地重复“卧槽”，猫儿山的景观就是只能这样地形容。</p><p><img src="https://joyerliii.github.io/2022-1-28-1/8.jpg"></p><p>经常见到云海以及云海日出的朋友可能不会有这样的感受，但是对于没见过的人，真的是一个非常好的去处。没错，猫儿山的招牌，就是太阳和云彩。</p><p>如果你在猫儿山过夜，我的建议是在下午2点左右就到达景区门口然后进场等待景区摆渡车带上山，上山大概是一小时车程。放好行李后随即又跟摆渡车到山上的一些游览点去观赏，山里游览点不少，我们就是因为赶下午五点最后一班上山摆渡车而失去了游览其他地方的时间，可谓是浪费了些门票钱。到了傍晚可以在云海上观赏到漂亮的日落，所以游览其他项目一定要把握好时间，避免观赏不到主要项目。猫儿山最最不能错过的就是太阳，星星，以及云彩。</p><p>到了晚上可以到下榻的酒店吃晚餐，当然也可以自备自热米饭这些方便食品自己解决。（我们就没有购买山上的东西，我们认为山上的东西会很贵于是在地上买好需要的物资再上山的。）</p><p>吃完晚饭就一定要去洗澡了，酒店的热水供应时间是限时的。当洗完澡后可以考虑出到酒店门口看看星星，因为在云的上边，星星非常多。建议只在酒店周围活动，因为其他地方没有灯，并且要记得保暖，站得高风也大。</p><blockquote><p>为了看星星，挑选去猫儿山的时间很有讲究。如果你要完全看到明亮漂亮的满天星，要选择月初或者月末前往，一个月的每一天都对应着月亮的月盈月亏的不同形状。如果要看到银河，则需要在夏季的月初月末选择合适的时间前往，在夜空中抓住心宿二这颗明星，底下就是长长的银河带。（肉眼可能难以观测，需要借助相机调整参数拍摄）</p></blockquote><p><img src="https://joyerliii.github.io/2022-1-28-1/7.jpg"></p><p>看完星星就回酒店洗洗睡吧，第二天不能错过日出。</p><p><img src="https://joyerliii.github.io/2022-1-28-1/12.jpg"><br><img src="https://joyerliii.github.io/2022-1-28-1/9.jpg"></p><p>第二天看完日出吃完早餐后建议中午十二点下山，回程途中可以走国道四处看看转转，能近距离看到兴安的风力发电机阵（相信你在猫儿山上也能见到这个风力发电机阵）。这个风力发电机阵的地方是可以去的，位置是<a href="https://surl.amap.com/6IrvOqRc1l">兴安摩天岭</a> （原本我们也想去的，但是由于没做好规划不知道位置所以错过了这个地方）。</p><p><img src="https://joyerliii.github.io/2022-1-28-1/11.jpg"></p><p>PS：</p><ul><li>好玩的是我回去的时候给社交平台的朋友和亲人们反了不少图，很多人都说想去一次猫儿山。</li><li>山上有帐篷营地，可以选择不住在酒店</li><li>旅游淡季出行人少更好观景。</li><li>酒店服务不错，但似乎淡季床铺不勤换，朋友反馈说住了一晚身痒。</li><li>景区有时会因为天气原因而暂停营业，APP上的信息并不准确，需要自行打电话到景区确认。</li></ul><h3 id="兴坪古镇-大兴线-兴兰线"><a href="#兴坪古镇-大兴线-兴兰线" class="headerlink" title="兴坪古镇(大兴线/兴兰线)"></a><a href="https://surl.amap.com/7tfOA21baWA">兴坪古镇(大兴线/兴兰线)</a></h3><strong> 推荐程度：⭐⭐⭐✨<br>体验：⭐⭐⭐✨<br>门票：免费<br>游玩时长：1天<br></strong><p>这是我的8天自驾游旅途中的最后一个游玩项目了。熟悉我的人其实都知道我不喜欢去古镇之类的地方，傍着古镇的名义招摇行骗，把游客骗去宰一波。</p><p>我的目的当然不是为了这个古镇而跋山涉水了，而是跋山涉水途中的风景。常有人说兴兰线的风景如画，我去后绝赞不虚此行，确实值得一去。</p><p>兴兰线前段叫大兴线，是沿着漓江河岸的一条省道，在这里你大可停车观赏漓江的美景。</p><p><img src="https://joyerliii.github.io/2022-1-28-1/14.jpg"></p><p>大兴线结束后将会上山，接下来的路程即是一条蜿蜒的盘山公路，而随着海拔的升高能看到更多可以用来诠释桂林山水甲天下的漂亮的风景，行驶到一半会有一个观景台能够上去，整个桂林山水尽收眼底，但由于我们去的当天在下雨，于是错失了这样一个观赏的机会，只能走马观花地从车窗内往外瞭去；即使这样，从车里往外看也真的非常漂亮。</p><p><img src="https://joyerliii.github.io/2022-1-28-1/15.jpg"></p><p>目的地即是兴坪古镇，到这里可以走走。我们当天到达已经是晚上，随意逛逛便返程。可以确定的是兴坪古镇的老街确实是真正的老街，作为人像的背景很不错。</p><p><img src="https://joyerliii.github.io/2022-1-28-1/16.jpg"><br><img src="https://joyerliii.github.io/2022-1-28-1/17.jpg"></p><p>像这个景点来说可能有些人不太喜欢这样的边走边游，但我认为这算是一种乐趣所在<del>（风景佬狂喜）</del>。</p><p>建议回程不要太晚，因为有盘山公路如果太晚回程可能会遇到雾，开车安全为要。</p><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><p>那么8天以来游览的景点就这样介绍完毕了，大家如果有什么问题或者建议可在下方留言，为了让您能收到我的回复请填上自己的邮箱哦。</p><p>注意：本文插图除特别注明外皆拍摄自本文作者。严禁盗窃或未得到作者授权直接转载全文任何内容，获取内容转载权限请联系作者。</p>]]></content>
      
      
      <categories>
          
          <category> 旅游 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅游 </tag>
            
            <tag> 攻略 </tag>
            
            <tag> 桂林 </tag>
            
            <tag> 柳州 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决TrueNas Core/FreeNas的pkg不可用的问题</title>
      <link href="/2022-01-27-1/"/>
      <url>/2022-01-27-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>TrueNas Core/FreeNas是以FreeBSD为底层的Nas系统，所以自然也能使用pkg来安装软件，但是与FreeBSD不同的是，如果您直接在控制台使用 <code>#pkg  update</code> 或是直接使用pkg安装的话，会弹出这样的错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@truenas[~]# pkg update</span><br><span class="line">Updating local repository catalogue...</span><br><span class="line">pkg: file:///usr/ports/packages/meta.txz: No such file or directory</span><br><span class="line">repository local has no meta file, using default settings</span><br><span class="line">pkg: file:///usr/ports/packages/packagesite.pkg: No such file or directory</span><br><span class="line">pkg: file:///usr/ports/packages/packagesite.txz: No such file or directory</span><br><span class="line">Unable to update repository local</span><br><span class="line">Error updating repositories!</span><br></pre></td></tr></table></figure><hr><p>解决办法是：</p><ul><li>把 /usr/local/etc/pkg/repos/local.conf 中的 <code>yes</code> 改 <code>no</code></li><li>把 /usr/local/etc/pkg/repos/FreeBSD.conf 中的 <code>no</code> 改 <code>yes</code></li></ul><p>由此一来便可在控制台中直接使用pkg安装软件了。</p><p>要注意的是每次重启后系统会将usr/的数据还原，所以如果在重启后使用pkg还需要执行上面的操作，如果您觉得麻烦，将用于修改文件的命令写入开机任务当然也是可以的。</p><p>文段中部分搬运自<a href="http://events.jianshu.io/p/20b28fa3f51e">简书：FreeNAS</a> ，如侵删。</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
          <category> Nas </category>
          
          <category> TrueNas/FreeNas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Nas </tag>
            
            <tag> TrueNas </tag>
            
            <tag> FreeNas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022年了</title>
      <link href="/2022-01-22-1/"/>
      <url>/2022-01-22-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="2021来了"><a href="#2021来了" class="headerlink" title="2021来了"></a>2021来了</h2><p>最近是终于考试结束了然后马不停蹄地跑去玩，考试怎么样就随它去吧。<br>也把博客整理了一下顺便通过友链挖到了许多大佬，一打开链接我去内容那是真滴十分丰富，结果原本我还为自己的博客引以为傲称之为简约，看完之后我抑郁了，我这哪叫简约啊简直就是简陋哈哈哈。<br>2022年了，世间也不算太太平，原以为德尔塔已经是新冠疫情的尾声了，没想到又冒出来个奥密克戎，很是郁闷。这一次疫情真的被整到烦了，是真的没想到出门戴口罩会变成常态，所以我希望</p><p style="text-align:center;font-size:25px;"> 2022年疫情结束！！！ </p>当然了这也不仅仅是我自己的希望，也是所有人的希望，希望大家的希望能够成真吧。也非常感谢世界上的每一位抗击新冠病毒的大佬们，有了你们我们才能安全。<h2 id="关于LeetCode每日一题"><a href="#关于LeetCode每日一题" class="headerlink" title="关于LeetCode每日一题"></a>关于LeetCode每日一题</h2><p>LeetCode每日一题的计划一开始其实是为了督促我自己学习。作为计科的一名学生，本身我自己也在学习算法，这个计划中我对我自己的要求是写出就算小白也能懂的题解，这样才能让自己对这个题目能够完全学会，不过没人看就是了x。<br>LeetCode每日一题原本计划是每天一更的。但是有些题目实在过于简单发上来没啥意义，<del>再加上自己咕咕咕的本质</del>，开始断更了x，不过以后我还会一直写下去的，不论是为了自己还是为了寻找题解的童鞋们。<br><img src="https://joyerliii.github.io/2022-1-22-1/1.png"></p><h2 id="关于最近我在干什么"><a href="#关于最近我在干什么" class="headerlink" title="关于最近我在干什么"></a>关于最近我在干什么</h2><p>最近拿到了奖学金，拿着这笔钱租了一辆车和朋友疯了8天，在桂林和柳州之间疯狂地到处玩，请放心我在每个城市的游览结束后都去做了核酸，不仅仅是对别人负责，更重要的是对自己也要负责。<br>下一篇会出一篇游记，详细讲讲这8天我都玩了啥，同时也希望能帮助到想在桂林柳州玩耍的童鞋们，给他们提供一些建议。<br><img src="https://joyerliii.github.io/2022-1-22-1/2.png"></p><h2 id="吐槽点琐事"><a href="#吐槽点琐事" class="headerlink" title="吐槽点琐事"></a>吐槽点琐事</h2><p>前几天看到我的老家——一个小县城突然把城区里的大部分停车位的收费权卖了出去。。。也就是说，从今往后，我住的这个小县城大街上的车位都开始要收费了。。。<br>就怎么说，很离谱，本身就一个小县城，车位还不够停呢，这一弄直接够呛了，大伙的车都往哪停？很多小区里头车位是根本不够的，想买车位也没有卖。<br>不说别人，我也开始头疼了，原本想买一辆我人生中的第一辆车，却被绊死在车位问题上，实在是难受。难受也没办法，只能接受，我的第一辆车可能要延后到买房以后了，除非我不在老家工作。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
          <category> 瞎叭叭 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
            <tag> 瞎叭叭 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题 807. 保持城市天际线</title>
      <link href="/2021-12-13-1/"/>
      <url>/2021-12-13-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>我又来更新了！今天的题目是<a href="https://leetcode-cn.com/problems/max-increase-to-keep-city-skyline/">LeetCode 807. 保持城市天际线</a> ，是一道简单的中等难度的题。</p><p>先看题目。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一座由 n x n 个街区组成的城市，每个街区都包含一座立方体建筑。给你一个下标从 0 开始的 n x n 整数矩阵 grid ，其中 grid[r][c] 表示坐落于 r 行 c 列的建筑物的 高度 。</p><p>城市的 天际线 是从远处观察城市时，所有建筑物形成的外部轮廓。从东、南、西、北四个主要方向观测到的 天际线 可能不同。</p><p>我们被允许为 任意数量的建筑物 的高度增加 任意增量（不同建筑物的增量可能不同） 。 高度为 0 的建筑物的高度也可以增加。然而，增加的建筑物高度 不能影响 从任何主要方向观察城市得到的 天际线 。</p><p>在 不改变 从任何主要方向观测到的城市 天际线 的前提下，返回建筑物可以增加的 最大高度增量总和 。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这道题给了一个参照图，我们来看看。</p><p><img src="https://assets.leetcode.com/uploads/2021/06/21/807-ex1.png" alt="来源：LeetCode,如侵删"></p><p>题目的意思就是让我们增加城市中建筑的层数而不影响从城市周围东南西北4个方向上观察到的形状，所以我们只需要获取到从四周观察到的景象 Vector&lt;int&gt; north和 Vector&lt;int&gt; west ，以它们为参照增加城市中建筑的层数。</p><p>我们在给每一栋建筑盖楼时要注意只能修到这栋房子的横向最高那个建筑和纵向最高那个建筑之间相对矮的那个建筑，这样才能保证在另一个方向上没有超过它这一列最高的建筑而改变城市天际线的形状（这市长可能脑子有坑）。</p><p>我们只要计算好原本总共的楼层有多少还有盖完楼后总共的楼层有多少，再将他们相减，就是答案“建筑物可以增加的 最大高度增量总和 ”了。</p><p>来看代码。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxIncreaseKeepingSkyline</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> highest=<span class="number">0</span>,nowHight=<span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; north,west;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                highest=<span class="built_in">max</span>(highest,grid[i][j]);</span><br><span class="line">                nowHight+= grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            west.<span class="built_in">push_back</span>(highest);</span><br><span class="line">            highest=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid.<span class="built_in">size</span>();j++)</span><br><span class="line">                highest=<span class="built_in">max</span>(highest,grid[j][i]);</span><br><span class="line">            north.<span class="built_in">push_back</span>(highest);</span><br><span class="line">            highest=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxHight=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid.<span class="built_in">size</span>();j++)</span><br><span class="line">                maxHight+=<span class="built_in">min</span>(north[j],west[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxHight-nowHight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完事！</p><p>此解法非唯一解，且不一定是最好的解法，如果您有更好的解法，欢迎在评论区中提出。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
          <category> 学习日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题 1034. 边界着色</title>
      <link href="/2021-12-07-1/"/>
      <url>/2021-12-07-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>今天的每日一题是<a href="https://leetcode-cn.com/problems/coloring-a-border/">LeetCode每日一题 1034. 边界着色</a> 。</p><p>来看题目。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个大小为 m x n 的整数矩阵 grid ，表示一个网格。另给你三个整数 row、col 和 color 。网格中的每个值表示该位置处的网格块的颜色。</p><p>当两个网格块的颜色相同，而且在四个方向中任意一个方向上相邻时，它们属于同一 连通分量 。</p><p>连通分量的边界 是指连通分量中的所有与不在分量中的网格块相邻（四个方向上）的所有网格块，或者在网格的边界上（第一行/列或最后一行/列）的所有网格块。</p><p>请你使用指定颜色 color 为所有包含网格块 grid[row][col] 的 连通分量的边界 进行着色，并返回最终的网格grid 。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>老实说题目翻译得不准确，我看了许久还是翻了翻评论区，终于知道是什么意思。</p><p>题目的意思是给你个矩阵grid，然后在矩阵中指定一个元素grid[row][col]出来作为基准，让我们找这个元素的数字的连通分量的最大范围，并且还要在边界处涂上颜色Color，画个图理解一下。<br>例如矩阵grid长这样，指定的元素为gird[2][2]=2，color=3。</p><p><img src="https://joyerliii.github.io/2021-12-07-1/202112071.png"></p><p>那么我们可以知道2的最大连通分量区间为</p><p><img src="https://joyerliii.github.io/2021-12-07-1/202112073.png"></p><p>为连通分量的边界换上color=3,即返回结果</p><p><img src="https://joyerliii.github.io/2021-12-07-1/202112072.png"></p><p>那么我们要如何找到 grid[row][col] 的最大连通分量区间呢？很明显，使用搜索。<br>本篇展示的是广度搜索(BFS),这道题当然也能使用深度搜索(DFS)来计算，您可以自己尝试编写算法。</p><p>我们以 grid[row][col] 为起点开始搜索以 grid[row][col] 为中心的连通分量区。</p><p>符合作为grid[row][col]元素的连通分量有的特征是与上下左右四面相邻的方块至少一块“颜色”（即数据）相同。</p><p>符合作为grid[row][col]元素的连通分量边界的特征：第一要是一个连通变量并且“颜色”与grid相同且处于一个区内，第二个是与一定与其他“颜色”为邻，像这样的连通分量我们要为它涂上“颜色”Color。</p><ul><li>所以程序运行的流程逻辑分为以下几点。</li></ul><p>1、判断 grid[i][j] 是否为与 grid[row][col] 相同的连通分量，是就改为0，防止在同一位置重复运行导致死循环。</p><p>2、判断 grid[i][j] 是否为连通分量边界，为了防止相邻元素判断时与更换后连通分量边界元素发生判断性错误，改为-grid[row][col] 。</p><p>3、使用递归访问 grid[i][j] 的上下左右节点，重复1，2，3过程。</p><blockquote><p>PS：<br>在我的代码中，拥有一个vector&lt;vector<int>&gt; G = grid,它与grid进行同步修改，在grid[i][j]改成-grid[row][col]时直接向G[i][j]“染色”。完成流程后直接返回G即可。</int></p></blockquote><p>弄了个GIF，让大家能够快速理解。</p><p><img src="https://s4.ax1x.com/2021/12/08/ogh56A.gif"></p><p> 那么让我们开始码代码吧。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> col_co=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> Color=<span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; G;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">colorBorder</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> color) &#123;</span><br><span class="line">        col_co=grid[row][col];</span><br><span class="line">        Color=color;</span><br><span class="line">        G=grid;</span><br><span class="line">        <span class="built_in">find</span>(grid,row,col);</span><br><span class="line">        <span class="keyword">return</span> G;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid,<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=grid.<span class="built_in">size</span>() || j&gt;=grid[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(grid[i][j]==<span class="number">0</span> || <span class="built_in">abs</span>(grid[i][j])!=col_co)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j]==col_co)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( i==<span class="number">0</span> || j==<span class="number">0</span> || i==grid.<span class="built_in">size</span>()<span class="number">-1</span> || j==grid[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span> )</span><br><span class="line">                G[i][j]=Color,grid[i][j]=-col_co;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( (i<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; j<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; i+<span class="number">1</span>&lt;grid.<span class="built_in">size</span>() &amp;&amp; j+<span class="number">1</span>&lt;grid[<span class="number">0</span>].<span class="built_in">size</span>()) &amp;&amp; </span><br><span class="line">           ((<span class="built_in">abs</span>(grid[i<span class="number">-1</span>][j])!=col_co &amp;&amp; grid[i<span class="number">-1</span>][j]!=<span class="number">0</span> ) || </span><br><span class="line">            (<span class="built_in">abs</span>(grid[i+<span class="number">1</span>][j])!=col_co &amp;&amp; grid[i+<span class="number">1</span>][j]!=<span class="number">0</span> ) || </span><br><span class="line">            (<span class="built_in">abs</span>(grid[i][j<span class="number">-1</span>])!=col_co &amp;&amp; grid[i][j<span class="number">-1</span>]!=<span class="number">0</span> ) || </span><br><span class="line">            (<span class="built_in">abs</span>(grid[i][j+<span class="number">1</span>])!=col_co &amp;&amp; grid[i][j+<span class="number">1</span>]!=<span class="number">0</span> ) ) </span><br><span class="line">            )</span><br><span class="line">                G[i][j]=Color,grid[i][j]=-col_co;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                grid[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">find</span>(grid,i+<span class="number">1</span>,j);</span><br><span class="line">            <span class="built_in">find</span>(grid,i<span class="number">-1</span>,j);</span><br><span class="line">            <span class="built_in">find</span>(grid,i,j+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">find</span>(grid,i,j<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此解法非唯一解，且不一定是最好的解法，如果您有更好的解法，欢迎在评论区中提出。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
          <category> 学习日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 广度搜索 </tag>
            
            <tag> BFS </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K-ON!! (内含音乐，请确认您所处环境是否适合播放音乐后打开)</title>
      <link href="/xiabb-1/"/>
      <url>/xiabb-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div style="font-size:50px;font-family:arial">山田尚子是神！</div><p><img src="https://joyerliii.github.io/xiabb-1/2.jpeg"></p><p>提及轻音少女，你可能想到的是 moe 系的开始，或者是”滑滑蛋“，又或者是……</p><p>轻音少女只是一部提及些许音乐元素谈及一群女高中生的日常的番剧。但是剧中的每一处画面，每一个细节，每一首音乐，都令我在其中陶醉，为她们的故事而高兴，而着急，而感动。</p><p>本文章使用了音乐插件，播放的是来自 K-ON! Music History’s Box （轻音少女音乐合集）专辑中整理出来的播放列表，是 放課後ティータイム （放学后下午茶时间） 乐队在TV版第二季中为下一届轻音社准备的礼物——记录着她们的美好时光的磁带中的内容，如果您有时间，可以留在此页，听听从她们的歌中传来的幸福、开心与感动(播放器在底部)。</p><div style="font-size:30px;font-family:arial">“不是很精彩呢”</div>但是一起做了，努力过了，不是吗。<p>可以说轻音少女为我指引了于人生的一分界点，是轻音少女让我接触到了真正的律动，使我从低谷中醒悟，虽然只领悟了些皮毛，但我依然感激。我本以为我不会是拿起吉他弹着曲子唱着歌的”盲流子“，看完轻音少女后，我还是下定决心，开始学起了吉他，若他日有机缘，我也希望能得到一把中野梓的红色 Fender Mustang。</p><p><img src="https://joyerliii.github.io/xiabb-1/3.jpg"></p><p>心血来潮想在我的博客下写进关于轻音少女的一段话，手悬在键盘上却不知如何开始，便将心中所想码入编辑器中，然而看完轻音少女何况过了两年了，在码字中途还是不由得热泪盈眶，这就是所谓轻音少女带给我的感动了吧。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="450" src="//music.163.com/outchain/player?type=0&id=5037125984&auto=1&height=430"></iframe>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
          <category> 瞎叭叭 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
            <tag> 瞎叭叭 </tag>
            
            <tag> 京都动画 </tag>
            
            <tag> 动漫 </tag>
            
            <tag> k-on </tag>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ String变量 与 &lt;string.h&gt;库</title>
      <link href="/2021-12-06-2/"/>
      <url>/2021-12-06-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>介绍一下 C++ String 变量与 &lt;string.h&gt; 库。</p><h2 id="正片"><a href="#正片" class="headerlink" title="正片"></a><div>正片</div></h2><h3 id="String变量类型"><a href="#String变量类型" class="headerlink" title="String变量类型"></a><div>String变量类型</div></h3><p>String变量类型即字符串变量类型，有关它的初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str;                   <span class="comment">//初始化一个str变量，默认为&quot;&quot;</span></span><br><span class="line">string str2 = <span class="string">&quot;Hello World&quot;</span>;  <span class="comment">//初始化一个str2并赋值&quot;Hello World&quot;</span></span><br><span class="line">string str3 = str2;           <span class="comment">//初始化一个str3并拷贝str2</span></span><br><span class="line"><span class="function">string <span class="title">str4</span><span class="params">(<span class="number">10</span>,<span class="string">&#x27;s&#x27;</span>)</span></span>;          <span class="comment">//初始化一个str4并给其赋值10个&#x27;s&#x27;,即&#x27;ssssssssss&#x27;</span></span><br><span class="line"><span class="function">string <span class="title">str5</span><span class="params">(<span class="string">&quot;string&quot;</span>)</span></span>;        <span class="comment">//初始化一个str5变量并赋值为&quot;string&quot;</span></span><br></pre></td></tr></table></figure><p>String变量类型可以当作一个char数组来使用,但它不是char数组，如果您想转换成char*字符串，请向下翻阅 string.c_str() 函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">cout&lt;&lt;str[<span class="number">3</span>]&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d</span><br></pre></td></tr></table></figure><ul><li>string变量的加法</li></ul><p>c++的string类型变量能够使用’+’相加，返回结果是两者拼接后的string字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str=Hello;</span><br><span class="line">string str2=World;</span><br><span class="line">cout&lt;&lt;str+<span class="string">&quot; &quot;</span>+str2&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World</span><br></pre></td></tr></table></figure><h3 id="String-h-库-常用函数"><a href="#String-h-库-常用函数" class="headerlink" title="String.h 库 常用函数"></a><div>String.h 库 常用函数</div></h3><h4 id="string-to-string"><a href="#string-to-string" class="headerlink" title="string to_string()"></a>string to_string()</h4><p>我想第一个就介绍它，to_string()是我们经常且频繁会用到的一个函数,它用于将数值转换为string字符串,并返回转换后的string字符串。</p><ul><li>string to_string()的参数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="keyword">long</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="keyword">unsigned</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="keyword">float</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="keyword">double</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> val)</span></span>;</span><br></pre></td></tr></table></figure>应用：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="built_in">to_string</span>(<span class="number">123</span>) + <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">cout&lt;&lt;str&lt;&lt;endl;</span><br></pre></td></tr></table></figure>输出为<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span>abc</span><br></pre></td></tr></table></figure></li></ul><h4 id="double-stod-string-str-、float-stof-string-str-、int-stoi-string-str"><a href="#double-stod-string-str-、float-stof-string-str-、int-stoi-string-str" class="headerlink" title="double stod(string str)、float stof(string str)、int stoi(string str)"></a>double stod(string str)、float stof(string str)、int stoi(string str)</h4><p>这几个也是非常重要的函数，并也是经常使用的函数。具体作用为将str转换为相应的数值类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;<span class="built_in">stod</span>(<span class="string">&quot;13.4&quot;</span>)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="built_in">stoi</span>(<span class="string">&quot;13&quot;</span>)+<span class="built_in">stof</span>(<span class="string">&quot;13.4&quot;</span>)&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13.4</span></span><br><span class="line"><span class="number">26.4</span></span><br></pre></td></tr></table></figure><p>除了标题中的几个，还有long long stoll(string str)、unsigned stoul(string str)等等，不再赘述。 </p><h4 id="void-swap-string-a-string-b"><a href="#void-swap-string-a-string-b" class="headerlink" title="void swap(string a , string b)"></a>void swap(string a , string b)</h4><p>将a字符串与b字符串交换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string a=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">string b=<span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="built_in">swap</span>(a,b);</span><br><span class="line">cout&lt;&lt; a &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; b &lt;&lt;ndl;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span> abc</span><br></pre></td></tr></table></figure><h4 id="string-strrev-string-str"><a href="#string-strrev-string-str" class="headerlink" title="string strrev(string str)"></a>string strrev(string str)</h4><p>倒转字符串中的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">cout&lt;&lt; <span class="built_in">strrev</span>(str) &lt;&lt;ndl;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cba</span><br></pre></td></tr></table></figure><h3 id="String-方法"><a href="#String-方法" class="headerlink" title="String 方法"></a><div>String 方法</div></h3><h4 id="iterator-string-begin"><a href="#iterator-string-begin" class="headerlink" title="iterator string.begin()"></a>iterator string.begin()</h4><p>指向string类型变量的首位字符迭代器</p><h4 id="iterator-string-end"><a href="#iterator-string-end" class="headerlink" title="iterator string.end()"></a>iterator string.end()</h4><p>指向string类型变量的末位字符迭代器的后一位。</p><h4 id="int-string-find"><a href="#int-string-find" class="headerlink" title="int string.find()"></a>int string.find()</h4><p>寻找来自string类型变量的某位字符或字符串位置,返回其下标。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string.<span class="built_in">find</span>(<span class="keyword">char</span> chr);</span><br><span class="line">string.<span class="built_in">find</span>(<span class="keyword">char</span> chr, <span class="keyword">int</span> n);</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;abcabc&quot;</span>;</span><br><span class="line">cout&lt;&lt;str.<span class="built_in">find</span>(<span class="string">&#x27;a&#x27;</span>)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;str.<span class="built_in">find</span>(<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h4 id="string-string-substr"><a href="#string-string-substr" class="headerlink" title="string string.substr()"></a>string string.substr()</h4><p>截取字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string string.<span class="built_in">substr</span>()  <span class="comment">//不写参数默认返回string</span></span><br><span class="line">string string.<span class="built_in">substr</span>(<span class="keyword">int</span> n) <span class="comment">//从string下标为n开始的位置向后截取到尾返回</span></span><br><span class="line">string string.<span class="built_in">substr</span>(<span class="keyword">int</span> n1,<span class="keyword">int</span> n2) <span class="comment">//从string下标为n1开始向后截取到n2</span></span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">cout&lt;&lt;str.<span class="built_in">substr</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;str.<span class="built_in">substr</span>(<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;str.<span class="built_in">substr</span>(<span class="number">2</span>,<span class="number">4</span>)&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abcdefg</span><br><span class="line">cdefg</span><br><span class="line">cde</span><br></pre></td></tr></table></figure><h4 id="string-string-erase"><a href="#string-string-erase" class="headerlink" title="string string.erase()"></a>string string.erase()</h4><p>删除字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string string.<span class="built_in">erase</span>(<span class="keyword">int</span> n); <span class="comment">//从string下标为n开始的位置向后删除到尾返回</span></span><br><span class="line">string string.<span class="built_in">erasee</span>(<span class="keyword">int</span> n1,<span class="keyword">int</span> n2); <span class="comment">//从string中删除n1到n2的字符串</span></span><br><span class="line">iterator string.<span class="built_in">erasee</span>(iterator n);<span class="comment">//从迭代器n指向的位置向后删除到尾返回</span></span><br><span class="line">iterator string.<span class="built_in">erasee</span>(iterator n1,iterator n2);<span class="comment">//从string中删除n1迭代器到n2迭代器指向的字符串</span></span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">cout&lt;&lt;str.<span class="built_in">erase</span>(str.<span class="built_in">begin</span>()+<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;str.<span class="built_in">erase</span>(str.<span class="built_in">begin</span>()+<span class="number">1</span>,str.<span class="built_in">end</span>()<span class="number">-3</span>)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;str.<span class="built_in">erase</span>(<span class="number">2</span>,<span class="number">4</span>)&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">afg</span><br><span class="line">abfg</span><br></pre></td></tr></table></figure><h4 id="char-string-c-char"><a href="#char-string-c-char" class="headerlink" title="char *string.c_char()"></a>char *string.c_char()</h4><p>将string字符串转换为经典C中的char*字符串</p><hr><p>先更新那么多，实在是记不太清楚，有些成员函数可能有遗漏，如有大佬发现问题麻烦在评论区留言,我将将其订正，如果在以后想起来了有关于string的用法我还会更新到这篇文章中。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> C++ </category>
          
          <category> 学习日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> String.h </tag>
            
            <tag> 编程基础 </tag>
            
            <tag> C++标准库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题 1816. 截断句子</title>
      <link href="/2021-12-06-1/"/>
      <url>/2021-12-06-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>LeetCode今天又是简单题。。。，好吧，我服。<br><a href="https://leetcode-cn.com/problems/truncate-sentence/">LeetCode 1816. 截断句子</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><div>题目</div></h2><p>句子 是一个单词列表，列表中的单词之间用单个空格隔开，且不存在前导或尾随空格。每个单词仅由大小写英文字母组成（不含标点符号）。</p><p>例如，”Hello World”、”HELLO” 和 “hello world hello world” 都是句子。<br>给你一个句子 s 和一个整数 k ，请你将 s 截断 ，使截断后的句子仅含 前 k个单词。返回 截断 s 后得到的句子。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><div>题解</div></h2><p>这。。。这还有必要写题解吗。。。完全使用string.h库里的函数就行。<br>今天的题过于简单了，干脆借此来再开一章介绍一下c++的string类型变量和string.h库里的常用函数吧<a href="https://blog.joyer.top/2021/12/06/2021-12-06-2/">C++ String变量 与 &lt;string.h&gt;库</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><div>代码</div></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">truncateSentence</span><span class="params">(string s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">find</span>(<span class="string">&#x27; &#x27;</span>);<span class="comment">//寻找第一个空格位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k<span class="number">-1</span>;i++)</span><br><span class="line">            n=s.<span class="built_in">find</span>(<span class="string">&#x27; &#x27;</span>,n+<span class="number">1</span>);<span class="comment">//用n标记第k个空格位置</span></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(<span class="number">0</span>,n);<span class="comment">//截取0到n的字符子串输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然但是，此解法非唯一解，且不一定是最好的解法，如果您有更好的解法，欢迎在评论区中提出。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
          <category> 学习日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题 372.超级次方</title>
      <link href="/2021-12-05-1/"/>
      <url>/2021-12-05-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>今天的LeetCode每日一题是<a href="https://leetcode-cn.com/problems/super-pow/submissions/">LeetCode 372.超级次方</a> ，困难度为中等，先看题。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><div>题目</div></h2><p>你的任务是计算 a<sup>b</sup> 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><div>题解</div></h2><p>好家伙今天的题目那是十分的短啊，很明显是一道数学题。要计算a的b次方，题目中说了b是一个非常大的数并且是以数组的形式给出，瞅瞅数组的长度。。。。</p><ul><li>1 &lt;= a &lt;= 231 - 1</li><li>1 &lt;= b.length &lt;= 2000</li><li>0 &lt;= b[i] &lt;= 9</li><li>b 不含前导 0  </li></ul><p>我超，心脏骤停，2000的长度，直接硬算那肯定是不行了， long long 也承接不了那么大的数。</p><p>我们先从取模运算下手，设mod为被取模的数，我们已知</p><blockquote><p>ab % mod = (a % mod · b % mod) % mod</p></blockquote><p>那么如果是以此公式用在幂运算上呢？</p><blockquote><p>a<sup>2</sup> % mod = (a % mod · a % mod) % mod<br>a<sup>3</sup> % mod = (a<sup>2</sup> % mod · a % mod) % mod<br>……<br>a<sup>10</sup> % mod = (a<sup>9</sup> % mod · a % mod) % mod</p></blockquote><p>那么就非常明朗了，我们需要重新写一下pow()函数，来适配这个程序。</p><p>为了缩短时间复杂度，我们还要要解决幂运算，假如我们要计算a<sup>123</sup>，我们可以知道</p><blockquote><p>a<sup>123</sup>=(a<sup>100</sup>)<sup>1</sup> x (a<sup>10</sup>)<sup>2</sup> x (a<sup>1</sup>)<sup>3</sup></p></blockquote><p>这样我们就可以直接按数位来取数组b里的数而不用将数组b想办法转为数字型变量了。</p><blockquote><p>a<sup>b</sup>=(a<sup>100</sup>)<sup>b[2]</sup> x (a<sup>10</sup>)<sup>b[1]</sup> x (a<sup>1</sup>)<sup>b[0]</sup></p></blockquote><p>ok，问题解决，让我们开始写代码吧。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a><div>代码示例</div></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, vector&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=a;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=b.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=(ans*<span class="built_in">pow</span>(x,b[i])%<span class="number">1337</span>);</span><br><span class="line">            x=<span class="built_in">pow</span>(x,<span class="number">10</span>);   <span class="comment">//计算a^[10^(b.size()-i)]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span>   <span class="comment">//按照取模运算的乘法公式改写一下pow()函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a=a%<span class="number">1337</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b;i++)</span><br><span class="line">            <span class="keyword">if</span>(a&lt;<span class="number">4294967296</span>)</span><br><span class="line">                ans=(ans*a)%<span class="number">1337</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完事，稍微有那么点绕，但是如果理解透彻后会很好懂。</p><p>此解法非唯一解，且不一定是最好的解法，如果您有更好的解法，欢迎在评论区中提出。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
          <category> 学习日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 数学 </tag>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题 383. 赎金信</title>
      <link href="/2021-12-04-1/"/>
      <url>/2021-12-04-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>LeetCode今天的每日一题又是难度为简单的题。。。。<br><a href="https://leetcode-cn.com/problems/ransom-note/">LeetCode 383. 赎金信</a><br>不管那么多，先看题目！</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><div>题目</div></h2><p>为了不在赎金信中暴露字迹，从杂志上搜索各个需要的字母，组成单词来表达意思。</p><p>给你一个赎金信 (ransomNote) 字符串和一个杂志(magazine)字符串，判断 ransomNote 能不能由 magazines 里面的字符构成。</p><p>如果可以构成，返回 true ；否则返回 false 。</p><p>magazine 中的每个字符只能在 ransomNote 中使用一次。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><div>题解</div></h2><p>很简单，使用一个哈希表统计 magazine 中的字符频率，然后循环一次 ransomNote 里的字符，如果哈希表中找不到这个字符，或是哈希表里这个字符的字频比 ransomNote 里的字频少，那么就 return false ，当循环结束，即证明ransomNote 能由 magazines 里面的字符构成， return true 。</p><p>直接上代码吧</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><div>代码</div></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ransomNote.<span class="built_in">size</span>()&gt;magazine.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; chr1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;magazine.<span class="built_in">size</span>();i++)</span><br><span class="line">            chr1[magazine[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ransomNote.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(chr1.<span class="built_in">find</span>(ransomNote[i])==chr1.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            chr1[ransomNote[i]]--;</span><br><span class="line">            <span class="keyword">if</span>(chr1[ransomNote[i]]&lt;<span class="number">0</span>)<span class="comment">//如果这个字符字频被减到0以下，则证明 ransomNote 不能由 magazines 里面的字符构成。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此解法非唯一解，且不一定是最好的解法，如果您有更好的解法，欢迎在评论区中提出。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
          <category> 学习日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无锡学院校园网 实现路由器自动登录上网 支持多设备连接</title>
      <link href="/2021-12-03-3/"/>
      <url>/2021-12-03-3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a><div align="left">开始之前</div></h1><p>我在学校收了一个路由器后，开始折腾起了实现校园网的自动登录，因为本校的校园网要求是一人一号，并且只要设备想用校园网必须要登录才能上网，非常的恼人，还给宿舍的IoT设备连接网络造成了一定的麻烦。</p><p>在这之前已经有学校的大佬做过脚本并成功实现了自动登录，由于校园网在本校转设以后进行了一次更新，在我Ctrl+V后发现代码并不通用，遂开始研究大佬的脚本，并也成功实现了自动登录。但是在此之前我对Shell脚本是完全没有了解过的，以下内容可能会有纰漏错误，请大佬们多多包含并在评论区指出我的文章中的不足之处，多谢。</p><p>在教程开始之前，先要感谢大佬们的教程文章使得我也能够成功实现自动登录，这里放上本篇教程的参考与引用，并特别感谢学校的KMnO<sub>4</sub>大佬写的本校自动登录教程。</p><p>校内KMnO<sub>4</sub>大佬的文章：<a href="https://www.coolapk.com/feed/25231797?shareKey=ZGJiYThmNTU1Y2ExNjFhYTVkNzM~&shareUid=1876394&shareFrom=com.coolapk.market_11.2.5">酷安：使用 Padavan 路由器实现校园网定时 Web 认证</a></p><p>来自甲烷气瓶博客的文章：<a href="https://jakting.com/archives/drcom-autologin-padavan-tgbot.html">Dr.COM校园网多设备解决方案——路由器 Padavan/LuCI 固件自动网页认证+Telegram Bot 定时发送连接情况</a></p><p>那么我们就废话不多说开始教程。</p><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a><div align="left">内容</div></h1><p>本篇教程理论上适用于部分学校的以哆点（Dr.com）为模板制作的以网页方式登录的校园网，请注意您的路由器一定是以linux为底层的高自定义化的路由器系统固件，像是Openwrt、梅林、Padavan等系统固件，或者说您的路由器本身就自带了计划任务执行Shell脚本功能当然也是可以的。<br>本文完成于2021年12月4日，截止到本文的最后修改时间2022年9月12日，处于本校（即南京信息工程大学滨江学院/无锡学院）中的校园网仍然能够以本篇教程的方法实现自动登录。</p><h2 id="能够实现的功能"><a href="#能够实现的功能" class="headerlink" title="能够实现的功能"></a><div align="left">能够实现的功能</div></h2><ul><li>自动登录校园网（废话）</li><li>直接使用设备连接路由器并开始使用校园网而不需要登录</li><li>如果有需要，还可以多开几个虚拟机使用多个账号进行网络聚合以获得更高带宽（本教程不涉及，仅提供思路）</li></ul><h2 id="第一步，获取GET-url"><a href="#第一步，获取GET-url" class="headerlink" title="第一步，获取GET url"></a><div align="left">第一步，获取GET url</div></h2><p>使用浏览器（最好是 Chrome 的内核浏览器）打开你的校园网链接，如本校的就是<a href="http://10.1.99.100/">南京信息工程大学滨江学院/无锡学院校园网登录界面</a>。<br>按<code>F12</code>打开开发人员工具，选择<code>网络（NetWork）</code>，勾选<code>保存日志（Preserve log）</code>，并在页面中进行正常登陆。</p><p><img src="https://joyerliii.github.io/2021-12-03-3/1.png"></p><p>登录完成后，在开发者工具中的<code>网络（NetWork）</code>子页中寻找<code>请求url（GET url）</code></p><p><img src="https://joyerliii.github.io/2021-12-03-3/2.png"></p><blockquote><p>（很神奇的是用不到POST，一些学校的网页登录可能需要用到POST而不能是GET，如果您发现GET不能成功登录，可以转至文章顶部寻找甲烷气瓶博客写的教程，写得非常好）</p></blockquote><p>，一般来说是这么个格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://10.1.99.100:801/eportal/portal/login?callback=dr1003&amp;login_method=1&amp;user_account=,0,账号@cmcc&amp;user_password=密码&amp;wlan_user_ip=内网IP&amp;wlan_user_ipv6=&amp;wlan_user_mac=设备MAC&amp;wlan_ac_ip=10.1.1.1&amp;wlan_ac_name=&amp;jsVersion=4.1.3&amp;terminal_type=1&amp;lang=zh-cn&amp;v=9960&amp;lang=zh</span><br></pre></td></tr></table></figure><p>把这个url记下来，随后退出校园网登录，我们要测试这个url是否能够使用。</p><p>以Windows11系统为例，我们需要在<code>系统设置</code>-<code>网络和Internet</code>-<code>高级网络设置</code>-<code>硬件和连接属性</code> 中查找用来测试的设备的内网IP（以本校为例一般是10.x.x.x）（Windows这货藏重要信息是越来越能藏了），其他系统的设备请自行解决获取内网IP，网络上有很多办法。</p><p>获取到IP以后，我们要替换url中的<code>wlan_user_ip=</code>后面的IP（为了防止IP自动更换），并把它粘贴到浏览器网址栏中，敲击回车，如果显示登陆成功，恭喜你，这篇教程对你有用，请继续向下看，如果失败了请转到文章开头提到的甲烷气瓶博客的文章。</p><p>解决完请求url，我们要开始操作路由器获取它的内网IP了。</p><h2 id="第二步，获取路由器内网IP"><a href="#第二步，获取路由器内网IP" class="headerlink" title="第二步，获取路由器内网IP"></a><div align="left">第二步，获取路由器内网IP</div></h2><p>为什么要获取内网IP呢，直接填入路由器的内网IP不行吗？因为校园网给予设备的IP是动态的，并且其生命只有一天甚至更少，所以我们每登录一次就要获取一次内网IP。</p><p>将你的路由器连上校园网，并用一台设备连接到路由器以便对路由器进行操作。进入你的路由器后台终端，也就是常说的黑底白字看起来贼高端的命令行窗口。一般来说路由器后台网页中可以找得到，您也可以用通过ssh登录进入路由器后台，但无论是哪种方式，切记一定要以管理员账号登陆，默认是root。</p><p>大部分的以Linux开发的系统都可以使用 <code>ip addr</code> 这条命令获取到设备的大部分网络信息，如果没找到，请尝试 <code>ifconfig</code>，都能获取到内网ip。<br><img src="https://joyerliii.github.io/2021-12-03-3/4.png"><br>随后，请在密密麻麻的字行间找到属于您的路由器的内网ip，我们就只要它，请您记住这个位置，我们要开始截取它了。</p><p>这里给出我截取路由器内网ip地址的命令，您可以按照这个命令进行参考。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ip addr | grep eth0.1 | grep inet | awk &#x27;&#123;print $2&#125;&#x27; | cut -d &quot;/&quot; -f 1</span><br></pre></td></tr></table></figure><p>正所谓授人以鱼不如授人以渔，并且您需要按照您路由器的自身情况参与到构成专属于您的路由器的截取内网IP的命令中来，下面我来仔细讲讲用这行命令是如何截取出我们需要的内网IP的， 请看以下表格中对应的命令的具体作用，但羞于文笔不好，如果有不理解的可以前往表格中所指的链接查看更多（菜鸟教程对于学习计算机相关的朋友来说真是个好东西）。</p><p>请注意您的命令格式，使用 | 将两个命令隔开，“|”两边带有空格，并且第一个命令一定是<code>ip addr</code>（也就是您需要截取的内容的获取命令）</p><p>一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr | grep inet</span><br></pre></td></tr></table></figure><table><thead><tr><th>命令</th><th>grep inet</th><th>awk ‘{print $2}’</th><th>cut -d “/“ -f 1</th></tr></thead><tbody><tr><td>作用</td><td>定位到关键词”inet”的所在行</td><td>截取出当行的第2个字符块</td><td>截取出以”/“字符分割的前字符块</td></tr><tr><td>详细</td><td><a href="https://www.runoob.com/linux/linux-comm-grep.html">菜鸟教程Linux grep</a></td><td><a href="https://www.runoob.com/linux/linux-comm-awk.html">菜鸟教程Linux awk</a></td><td><a href="https://www.runoob.com/linux/linux-comm-cut.html">菜鸟教程Linux cut</a></td></tr></tbody></table><p>首先第一个，<code>grep eth0.1</code>的作用，从字段中找到含有此关键词的对应行，这里我使用连接了校园网的网卡名称进行定位。</p><p>定位的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eth0.1@eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether 88:c3:97:b4:65:b9 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.2.91.138/18 brd 10.2.127.255 scope global eth0.1</span><br></pre></td></tr></table></figure><p>第二个，<code>grep inet</code>，不再赘述，这里是直接截取到有内网IP的那一行。</p><p>截取结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inet 10.2.91.138/18 brd 10.2.127.255 scope global eth0.1</span><br></pre></td></tr></table></figure><p>第三个，<code>awk &#39;&#123;print $2&#125;&#39;</code>,截取出第二个子块，也就是 inet 后面的IP，如果是<code>awk &#39;&#123;print $1&#125;&#39;</code>，截取出来的则是 inte 。</p><p>截取结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10.2.91.138/18</span><br></pre></td></tr></table></figure><p>还没完，我们还需要把子网掩码去掉，也就是‘/’后面的内容，第四个命令<code>cut -d &quot;/&quot; -f 1</code> ，这是个带有参数的命令，作用是截取“/”之前的文字段，如果 -f 的参数写的是 2，你将得到子网掩码 18。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10.2.91.138</span><br></pre></td></tr></table></figure><p>如果您如上成功写出您的命令并以此获取内网IP，那么请保存好这条命令。恭喜你，第二步的工作完成了，我们终于可以开始编写Shell脚本了！</p><h2 id="第三步，编写脚本"><a href="#第三步，编写脚本" class="headerlink" title="第三步，编写脚本"></a><div align="left">第三步，编写脚本</div></h2><p>新建一个文本文档，用 Notepad++ 打开它，当然其他文本编辑器也是可以的。</p><p>这里给出我的脚本，仅供参考。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CURRENT_IP=$(ip addr | grep eth0.1 | grep inet | awk &#x27;&#123;print $2&#125;&#x27; | cut -d &quot;/&quot; -f 1)</span><br><span class="line">#linux</span><br><span class="line">curl &#x27;http://10.1.99.100:801/eportal/portal/login?callback=dr1003&amp;login_method=1&amp;user_account=,0,账号@cmcc&amp;user_password=密码&amp;wlan_user_ip=&#x27;$CURRENT_IP&#x27;&amp;wlan_user_ipv6=&amp;wlan_user_mac=000000000000&amp;wlan_ac_ip=10.1.1.1&amp;wlan_ac_name=&amp;jsVersion=4.1.3&amp;terminal_type=1&amp;lang=zh-cn&amp;v=9960&amp;lang=zh&#x27;</span><br></pre></td></tr></table></figure><p>第一行定义一个变量 <code>CURRENT_IP</code> ，我们用它来存放内网IP，等号后面输入 $() （括号里放第二步您成功截取路由器IP的命令）。</p><p>第二行执行curl，后面使用单引号括住您在第一步能用来成功登录校园网的请求 url，并且将其中<code>wlan_user_ip</code>等号后面的内容改成变量<code>&#39;$CURRENT_IP&#39;</code></p><p>Ctrl+S保存。</p><p>这样一来，Shell 脚本也编好了。</p><h2 id="第四步，上传路由器"><a href="#第四步，上传路由器" class="headerlink" title="第四步，上传路由器"></a><div align="left">第四步，上传路由器</div></h2><p>我们接下来需要将它上传到路由器中，有很多办法。</p><ul><li>方法一</li></ul><p>将上文编辑好的文本文档改成<code>UTF-8</code>编码，像是在 NotePad++ 的顶栏中找到<code>编码</code>-<code>转为UTF-8编码</code>，保存退出。</p><p><img src="https://joyerliii.github.io/2021-12-03-3/6.png"></p><p>改变后缀，从 <code>.txt</code> 改成 <code>.sh</code> ,并且用英文命名，如<code>auto_log.sh</code>(以下都以此文件名示范)。</p><p>使用SSH或路由器管理网页的文件管理将这个脚本上传到路由器的<code>\etc\storage\</code>文件夹中，</p><p>如果没有这个文件夹，请在路由器的命令行窗口中使用命令创建这个文件夹。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">进入storage文件夹的步骤，请一行行执行命令</span><br><span class="line"># cd /etc</span><br><span class="line"># cd storage</span><br><span class="line">如果发现没有这个文件夹，请执行创建文件夹指令</span><br><span class="line"># mkdir storage</span><br></pre></td></tr></table></figure><p>然后在路由器管理页面的文件管理中上传sh文件到\etc\storage\里</p><p>如果使用 ssh 上传，可以在 Windows 的 PassShell 中执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp 本地脚本文件位置 路由器用户名@路由器IP:/etc/storage/</span><br></pre></td></tr></table></figure><ul><li>方法二</li></ul><p>在路由器终端中，输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请一行行执行命令</span><br><span class="line"># cd /etc/storage</span><br><span class="line">如果没有这个文件夹，参照方法一中创建</span><br><span class="line"></span><br><span class="line">nano auto_log.sh</span><br></pre></td></tr></table></figure><p>然后将本地的脚本内容直接复制到里面，使用<code>Ctrl+X</code>退出，输入Y后再敲击一次回车保存。</p><hr><p>方法很多，不再一一赘述，接下来我们要开始测试脚本是否可用，在路由器终端中输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh /etc/storage/auto_log.sh</span><br></pre></td></tr></table></figure><p>如果您是完全按照教程中的流程走，返回为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dr1003(&#123;&quot;result&quot;:0,&quot;msg&quot;:&quot;IP: 10.x.x.x 已经在线！&quot;,&quot;ret_code&quot;:2&#125;);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dr1003(&#123;&quot;result&quot;:1,&quot;msg&quot;:&quot;Portal协议认证成功！&quot;&#125;)</span><br></pre></td></tr></table></figure><p>而不是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error xxxxxxxxxx</span><br></pre></td></tr></table></figure><p>恭喜您，此脚本可用，就差最后一步，我们就可以完成路由器的自动登录了。</p><h2 id="第五步，添加计划任务"><a href="#第五步，添加计划任务" class="headerlink" title="第五步，添加计划任务"></a><div align="left">第五步，添加计划任务</div></h2><p>打开您的路由器管理页面的自动计划,以 OpenWrt 为例<br>在底部添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00 8 * * * sh /etc/storage/auto_log.sh</span><br></pre></td></tr></table></figure><p><img src="https://joyerliii.github.io/2021-12-03-3/5.png"></p><p>运行时间可以自己定，在 <a href="https://crontab.guru/">crontab.guru</a> 中可以自行计算需要的 cron 指令</p><p>理论上来说这样就已经完成了自动登录的部署，您可以在第二天连上您路由器的 wifi 测试您的网络是否已经可以上网，如果成功，恭喜您，本篇教程成功使您的路由器成功的实现了自动登录校园网的功能。</p><h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><p>如果您在根据本篇教程进行部署中出现了不可解决的问题，可以在评论下留言，或是直接通过 <a href="mailto:JoyerBill@qq.com">邮箱</a> 联系我，我会尝试帮助您解决问题。</p><p><code>指路</code>：如果您是无锡学院/南京信息工程大学滨江学院的学生，除了本篇以路由器登陆为目的的脚本与自动计划的方法登录校园网外，您还可以参考查阅 <a href="https://gitee.com/iIceCube/AutoConnect">[Gitee] AutoConnect</a> 这样以 Windows 桌面程序为载体的自动登陆方案。</p><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>关于实现<code>路由器掉线自动重连</code>的部分可阅 <a href="https://blog.joyer.top/2022-05-01/">实现路由器检测网络状态并重新登录</a> 。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
            <tag> 自动登录 </tag>
            
            <tag> 校园网 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 704.二分查找</title>
      <link href="/2021-12-03-2/"/>
      <url>/2021-12-03-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>先看题目，题目来源<a href="https://leetcode-cn.com/problems/binary-search/">LeetCode 704.二分查找</a></p><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>非常简单易懂的题目，要求就是返回相应元素的下标。但这题的重点在于时间复杂度要实现O(log n)，如果您以后一看到要求这样的时间复杂度，那么就应该下意识地反应到这可能是一道需求二分算法求解的题目。如果没有这样的要求，我们完全可以使用时间复杂度为O(n)的遍历数组。</p><p>因为比较简单，所以就不详细展开了，您如果不理解二分法可以根据下面代码的注释来辅助理解。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a><div align="left">代码示例</div></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min=<span class="number">0</span>,max=nums.<span class="built_in">size</span>()<span class="number">-1</span>,mid=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(min&lt;=max)<span class="comment">//在min&gt;max后退出循环，则代表target在nums中不存在</span></span><br><span class="line">        &#123;</span><br><span class="line">            mid=(<span class="keyword">int</span>)(min+max)/<span class="number">2</span>;<span class="comment">//获取数组的中间下标</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target)  <span class="comment">//如果nums[mid]小于需要查找的target，则将范围缩小到mid+1与max之间</span></span><br><span class="line">                min=mid+<span class="number">1</span>; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)  <span class="comment">//反之如果大于target，则将范围缩小到min与mid-1之间</span></span><br><span class="line">                max=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">//如果是相等就直接返回下标即可</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此解法非唯一解，且不一定是最好的解法，如果您有更好的解法，欢迎在评论区中提出。</p><div align="left">PS</div>：<blockquote><p>经典的时间复杂度O(log n)除了二分法 还有 欧几里得算法 幂运算。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
          <category> 学习日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题：1005.K 次取反后最大化的数组和</title>
      <link href="/2021-12-03-1/"/>
      <url>/2021-12-03-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>今天的LeetCode题目又是难度为简单的题<a href="https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/">LeetCode 1005.K 次取反后最大化的数组和</a>，先来看题。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><div align="left">题目</div></h2><p>给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：</p><p>选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。<br>重复这个过程恰好 k 次。可以多次选择同一个下标 i 。</p><p>以这种方式修改数组后，返回数组 可能的最大和 。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><div align="left">题解</div></h2><p>读起来非常拗口而且难以理解，还好LeetCode的题目都会给示例，我们来看看。</p><h4 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a><div align="left">示例1：</div></h4><blockquote><p>输入：nums = [4,2,3], k = 1</p><p>输出：5</p><p>解释：选择下标 1 ，nums 变为 [4,-2,3] 。</p></blockquote><h4 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a><div align="left">示例2：</div></h4><blockquote><p>输入：nums = [2,-3,-1,5,-4], k = 2</p><p>输出：13</p><p>解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。</p></blockquote><p>看完以后，我终于理解了题目说的是啥意思，通俗的来说就是拿nums[i]进行k次的nums[i]*=-1，随后把nums里的元素加起来返回，而且要是最大值。</p><p>进行一波分析，从nums里拿出哪个元素进行变换，会使得最后的结果是最大呢，很显然是nums中最小的那个元素。</p><p>用示例2举个例子，nums=[2,3,-1,5,-4] ; k=2，我们将最小那个元素掏出，是nums[4]=-4,给它进行变换，得到nums[4]=4, 变化后的结果为nums=[2,3,1,5,4],完成了第一次转换，所以k–,k=1。再进行一次变换，掏出nums最小那个元素，为nums[2]=1, 给它进行变换，结果为nums=[2,3,-1,5,4],此时k=0，已经完成变换，返回最后nums中的元素的和，即为结果。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a><div align="left">代码示例</div></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">if</span>(nums[n]&gt;nums[i])</span><br><span class="line">                n=i;</span><br><span class="line">        k--;</span><br><span class="line">        nums[n]*=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums)</span><br><span class="line">                ans+=i;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">largestSumAfterKNegations</span>(nums,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a><div align="left">修改</div></h2><p>经过大佬指点，对上述代码进行优化。</p><p>原代码使用了递归的办法进行了深度为k次的递归，然而这是没有必要的，仅仅需要一个for循环即可搞定。<br>算法也可以进行优化，我们可以将nums使用sort()进行升序排序，从低位开始往上将0到k-1的负数倒转，如果发现nums[i]是正数，就跳出循环。<br>跳出循环后如果k!=0,那么就再次进行sort()排序，然后nums[0]*=(-1)^k),最后再输出结果。</p><p>优化过后执行时间从30ms缩减至4ms</p><h2 id="代码示例（改）"><a href="#代码示例（改）" class="headerlink" title="代码示例（改）"></a><div align="left">代码示例（改）</div></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;nums[i]&lt;<span class="number">0</span>&amp;&amp;i&lt;nums.<span class="built_in">size</span>()&amp;&amp;k!=<span class="number">0</span>;i++)</span><br><span class="line">            nums[i]*=<span class="number">-1</span>,k--;</span><br><span class="line">        <span class="keyword">if</span>(k!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">            nums[<span class="number">0</span>]*=<span class="built_in">pow</span>(<span class="number">-1</span>,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums)</span><br><span class="line">            ans+=i;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此解法非唯一解，且不一定是最好的解法，如果您有更好的解法，欢迎在评论区中提出。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
          <category> 学习日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题：506.相对名字</title>
      <link href="/2021-12-02-2/"/>
      <url>/2021-12-02-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>先来看看题目<a href="https://leetcode-cn.com/problems/relative-ranks">LeetCode 506.相对名字</a></p><h2 id="题目"><a href="#题目" class="headerlink" title=" 题目 "></a><div align="left"> 题目 </div></h2><p>给你一个长度为 n 的整数数组 score ，其中 score[i] 是第 i 位运动员在比赛中的得分。所有得分都 互不相同 。</p><p>运动员将根据得分 决定名次 ，其中名次第 1 的运动员得分最高，名次第 2 的运动员得分第 2 高，依此类推。运动员的名次决定了他们的获奖情况：</p><p>名次第 1 的运动员获金牌 “Gold Medal” 。<br>名次第 2 的运动员获银牌 “Silver Medal” 。<br>名次第 3 的运动员获铜牌 “Bronze Medal” 。<br>从名次第 4 到第 n 的运动员，只能获得他们的名次编号（即，名次第 x 的运动员获得编号 “x”）。<br>使用长度为 n 的数组 answer 返回获奖，其中 answer[i] 是第 i 位运动员的获奖情况。</p><h2 id="题解"><a href="#题解" class="headerlink" title=" 题解 "></a><div align="left"> 题解 </div></h2><p>题目的意思，是要我们把第i号的运动员的分数换成名次，然后以vector&lt;string&gt;返回，特别是前三名，要改成Gold Medal、Silver Medal、Bronze Medal。其实非常简单，下面来看解决方案。</p><p>1.先执行一次for循环，因为分数是唯一的，用Map保存得分与选手号,关系为&lt;得分，运动员&gt;。</p><p>2.对score执行一次降序排序后，其元素的下标就是获得这个分数的运动员的排名。</p><p>3.再执行一次for循环，将第i号运动员的排名填入vector&lt;string&gt;[i]中，表示为vector&lt;string&gt;[Map[score[i]]]= i+1，请慢慢消化这些关系。噢对了，</p><blockquote><p>”名次第 1 的运动员获金牌 “Gold Medal” 。<br>名次第 2 的运动员获银牌 “Silver Medal” 。<br>名次第 3 的运动员获铜牌 “Bronze Medal” 。“</p></blockquote><p>还记得它吗，如果名次表示为1，2，3，请记得为这些优秀的运动员们戴上相应的奖牌。</p><h2 id="代码"><a href="#代码" class="headerlink" title=" 代码 "></a><div align="left"> 代码 </div></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRelativeRanks</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; score)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; socre_m;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">ans</span><span class="params">(score.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;score.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            socre_m[score[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(score.<span class="built_in">rbegin</span>(),score.<span class="built_in">rend</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;score.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[socre_m[score[i]]]=<span class="built_in">to_string</span>(i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">                ans[socre_m[score[i]]]=<span class="string">&quot;Gold Medal&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">                ans[socre_m[score[i]]]=<span class="string">&quot;Silver Medal&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">                ans[socre_m[score[i]]]=<span class="string">&quot;Bronze Medal&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上就是我对于本题的自己的理解与做法，但这样的解法肯定不是最优解。如果您有更好的解决方法，欢迎在下方评论区回复。</p><h2 id="PS-："><a href="#PS-：" class="headerlink" title=" PS ："></a><div align="left"> PS ：</div></h2><blockquote><p>排序函数的使用方法sort(iterator begin，iterator end)，默认是升序。<br>对于一个c++的容器来说，如果想要降序排序，以vector为例子，就是sort(vecotr.rbegin()，vecotr.rend()),这是一个方便的写法。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
          <category> 学习日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特殊的回文日子</title>
      <link href="/2021-12-02-1/"/>
      <url>/2021-12-02-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>今天是一个特殊的日子</p> <p style="text-align:center;font-size:25px"> 2021年12月2日 </p><p>我们用纯数字来表示就是 </p><p style="text-align:center;font-size:25px"> 20211202 </p> <p>它是一个无论是从头读起还是从尾读起都是一样的数字，这样的数字我们称其为回文数。</p><p>类似的有</p><p style="text-align:center;font-size:25px"> 123321 3468643 101 </p> <p>为了纪念今天，引申出一道来自leetcode的简单的算法题  <a href="https://leetcode-cn.com/problems/palindrome-number/">Leetcode 9.回文数</a>。</p><p>题目是这样描述的</p><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。<br>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。</p><h2 id="第一种解法"><a href="#第一种解法" class="headerlink" title=" 第一种解法 "></a><div align="left"> 第一种解法 </div></h2><p>根据题意，我们用string num来表示整数x，我们只需要对比num[i]与num[num.size()-i-1]是否相同即可,贴上代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        string num=<span class="built_in">to_string</span>(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.<span class="built_in">size</span>()/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]!=num[num.<span class="built_in">size</span>()-i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="第二种解法"><a href="#第二种解法" class="headerlink" title=" 第二种解法 "></a><div align="left"> 第二种解法 </div></h2><p>下面描述另一种解法。</p><p>如果x确实是一个回文数，那么将其倒转后也与原数相等，我们只需要判断x与倒转后的结果是否相等即可。</p><blockquote><p><font color="red">需要特别强调一点的是,虽然形参x是以int类型定义，但倒转过后长度有可能会超出int的长度，所以我们应该使用long rev来承接倒转后的数据。（PS：由于LeetCode的C++编译器极其严格，在做题时我不得不添加一个if来判断rev是否超出长度，这当然也是另外的做法，毕竟条条大路通罗马）</font></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num=x;</span><br><span class="line">        <span class="keyword">int</span> rev=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> i;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(num)</span><br><span class="line">        &#123;</span><br><span class="line">            i=rev*<span class="number">10</span>+num%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;INT_MAX)</span><br><span class="line">                rev=i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            num/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x==rev)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>非常简单，但这样的解法肯定不是最优解。如果您有更好的解决方法，欢迎在下方评论区回复。</p><blockquote><h2 id="PS-："><a href="#PS-：" class="headerlink" title=" PS ："></a><div align="left"> PS ：</div></h2><p>关于倒转数据还有更优雅的函数来直接代替文中第二种解法的代码示例中巨大的while段，但似乎Leetcode没有这样的函数。<br>第一个 reverse(iterator begin,iterator begin)，来自algorithm库，适合容器使用。<br>第二个 strrev(string str),来自string.h库,适合string类型的变量使用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 特殊时间 </tag>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021-12-01-hello-world/"/>
      <url>/2021-12-01-hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p style="font-size:25px;font-family:arial;">您好</p>欢迎来到我的博客，2021年12月1日，也就是今天，是我的博客的出生日。这篇文章同时是用来测试的。因为是刚刚建立的博客，所以站里可能会有一些小问题，请多多包含，遇到问题可以在留言板或评论区中给我留言。如果您也有博客，欢迎前往[友链](https://blog.joyer.top/link/)在评论区底下留言与我互换友链信息。<p><img src="https://api.ghser.com/random/api.php" alt="来自三秋的API"></p><blockquote><h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title=" HelloWorld "></a><p style="text-align:center;font-size:25px;"> HelloWorld </p></h2></blockquote>                                                                                      <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;Hello, World!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
            <tag> 我的博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
